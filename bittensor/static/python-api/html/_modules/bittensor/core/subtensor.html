
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bittensor.core.subtensor &#8212; Bittensor SDK Docs  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bittensor-custom.css?v=c1dfe055" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/bittensor/core/subtensor';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo.svg" class="logo__image only-light" alt="Bittensor SDK Docs  documentation - Home"/>
    <img src="../../../_static/logo-dark-mode.svg" class="logo__image only-dark pst-js-only" alt="Bittensor SDK Docs  documentation - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../autoapi/index.html">API Reference</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../autoapi/bittensor/index.html">bittensor</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/bittensor/core/index.html">bittensor.core</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/async_subtensor/index.html">bittensor.core.async_subtensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/axon/index.html">bittensor.core.axon</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/chain_data/index.html">bittensor.core.chain_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/config/index.html">bittensor.core.config</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/dendrite/index.html">bittensor.core.dendrite</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/errors/index.html">bittensor.core.errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/extrinsics/index.html">bittensor.core.extrinsics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/metagraph/index.html">bittensor.core.metagraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/settings/index.html">bittensor.core.settings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/stream/index.html">bittensor.core.stream</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/subtensor/index.html">bittensor.core.subtensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/synapse/index.html">bittensor.core.synapse</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/tensor/index.html">bittensor.core.tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/threadpool/index.html">bittensor.core.threadpool</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/core/types/index.html">bittensor.core.types</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/bittensor/extras/index.html">bittensor.extras</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/extras/dev_framework/index.html">bittensor.extras.dev_framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/extras/subtensor_api/index.html">bittensor.extras.subtensor_api</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/extras/timelock/index.html">bittensor.extras.timelock</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/bittensor/utils/index.html">bittensor.utils</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/axon_utils/index.html">bittensor.utils.axon_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/balance/index.html">bittensor.utils.balance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/btlogging/index.html">bittensor.utils.btlogging</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/easy_imports/index.html">bittensor.utils.easy_imports</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/formatting/index.html">bittensor.utils.formatting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/liquidity/index.html">bittensor.utils.liquidity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/networking/index.html">bittensor.utils.networking</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/registration/index.html">bittensor.utils.registration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/subnets/index.html">bittensor.utils.subnets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/version/index.html">bittensor.utils.version</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/bittensor/utils/weight_utils/index.html">bittensor.utils.weight_utils</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/opentensor/btcli" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/opentensor/btcli/issues/new?title=Issue%20on%20page%20%2F_modules/bittensor/core/subtensor.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for bittensor.core.subtensor</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timezone</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">cast</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scalecodec</span>
<span class="kn">from</span> <span class="nn">async_substrate_interface.errors</span> <span class="kn">import</span> <span class="n">SubstrateRequestException</span>
<span class="kn">from</span> <span class="nn">async_substrate_interface.substrate_addons</span> <span class="kn">import</span> <span class="n">RetrySyncSubstrate</span>
<span class="kn">from</span> <span class="nn">async_substrate_interface.sync_substrate</span> <span class="kn">import</span> <span class="n">SubstrateInterface</span>
<span class="kn">from</span> <span class="nn">async_substrate_interface.types</span> <span class="kn">import</span> <span class="n">ScaleObj</span>
<span class="kn">from</span> <span class="nn">bittensor_drand</span> <span class="kn">import</span> <span class="n">get_encrypted_commitment</span>
<span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">NDArray</span>

<span class="kn">from</span> <span class="nn">bittensor.core.async_subtensor</span> <span class="kn">import</span> <span class="n">ProposalVoteData</span>
<span class="kn">from</span> <span class="nn">bittensor.core.axon</span> <span class="kn">import</span> <span class="n">Axon</span>
<span class="kn">from</span> <span class="nn">bittensor.core.chain_data</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DelegatedInfo</span><span class="p">,</span>
    <span class="n">DelegateInfo</span><span class="p">,</span>
    <span class="n">DynamicInfo</span><span class="p">,</span>
    <span class="n">MetagraphInfo</span><span class="p">,</span>
    <span class="n">NeuronInfo</span><span class="p">,</span>
    <span class="n">NeuronInfoLite</span><span class="p">,</span>
    <span class="n">SelectiveMetagraphIndex</span><span class="p">,</span>
    <span class="n">StakeInfo</span><span class="p">,</span>
    <span class="n">SubnetInfo</span><span class="p">,</span>
    <span class="n">SubnetIdentity</span><span class="p">,</span>
    <span class="n">SubnetHyperparameters</span><span class="p">,</span>
    <span class="n">WeightCommitInfo</span><span class="p">,</span>
    <span class="n">decode_account_id</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.chain_data.chain_identity</span> <span class="kn">import</span> <span class="n">ChainIdentity</span>
<span class="kn">from</span> <span class="nn">bittensor.core.chain_data.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">decode_block</span><span class="p">,</span>
    <span class="n">decode_metadata</span><span class="p">,</span>
    <span class="n">decode_revealed_commitment</span><span class="p">,</span>
    <span class="n">decode_revealed_commitment_with_hotkey</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.config</span> <span class="kn">import</span> <span class="n">Config</span>
<span class="kn">from</span> <span class="nn">bittensor.core.errors</span> <span class="kn">import</span> <span class="n">ChainError</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.children</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">set_children_extrinsic</span><span class="p">,</span>
    <span class="n">root_set_pending_childkey_cooldown_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.commit_reveal</span> <span class="kn">import</span> <span class="n">commit_reveal_v3_extrinsic</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.commit_weights</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">commit_weights_extrinsic</span><span class="p">,</span>
    <span class="n">reveal_weights_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.liquidity</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">add_liquidity_extrinsic</span><span class="p">,</span>
    <span class="n">modify_liquidity_extrinsic</span><span class="p">,</span>
    <span class="n">remove_liquidity_extrinsic</span><span class="p">,</span>
    <span class="n">toggle_user_liquidity_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.move_stake</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">transfer_stake_extrinsic</span><span class="p">,</span>
    <span class="n">swap_stake_extrinsic</span><span class="p">,</span>
    <span class="n">move_stake_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.registration</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">burned_register_extrinsic</span><span class="p">,</span>
    <span class="n">register_extrinsic</span><span class="p">,</span>
    <span class="n">register_subnet_extrinsic</span><span class="p">,</span>
    <span class="n">set_subnet_identity_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.root</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">root_register_extrinsic</span><span class="p">,</span>
    <span class="n">set_root_weights_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.serving</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_last_bonds_reset</span><span class="p">,</span>
    <span class="n">publish_metadata</span><span class="p">,</span>
    <span class="n">get_metadata</span><span class="p">,</span>
    <span class="n">serve_axon_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.set_weights</span> <span class="kn">import</span> <span class="n">set_weights_extrinsic</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.staking</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">add_stake_extrinsic</span><span class="p">,</span>
    <span class="n">add_stake_multiple_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.start_call</span> <span class="kn">import</span> <span class="n">start_call_extrinsic</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.take</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">decrease_take_extrinsic</span><span class="p">,</span>
    <span class="n">increase_take_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.transfer</span> <span class="kn">import</span> <span class="n">transfer_extrinsic</span>
<span class="kn">from</span> <span class="nn">bittensor.core.extrinsics.unstaking</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">unstake_all_extrinsic</span><span class="p">,</span>
    <span class="n">unstake_extrinsic</span><span class="p">,</span>
    <span class="n">unstake_multiple_extrinsic</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.metagraph</span> <span class="kn">import</span> <span class="n">Metagraph</span>
<span class="kn">from</span> <span class="nn">bittensor.core.settings</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">version_as_int</span><span class="p">,</span>
    <span class="n">SS58_FORMAT</span><span class="p">,</span>
    <span class="n">TYPE_REGISTRY</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.core.types</span> <span class="kn">import</span> <span class="n">ParamWithTypes</span><span class="p">,</span> <span class="n">SubtensorMixin</span>
<span class="kn">from</span> <span class="nn">bittensor.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Certificate</span><span class="p">,</span>
    <span class="n">decode_hex_identity_dict</span><span class="p">,</span>
    <span class="n">format_error_message</span><span class="p">,</span>
    <span class="n">is_valid_ss58_address</span><span class="p">,</span>
    <span class="n">torch</span><span class="p">,</span>
    <span class="n">u16_normalized_float</span><span class="p">,</span>
    <span class="n">u64_normalized_float</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.balance</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Balance</span><span class="p">,</span>
    <span class="n">fixed_to_float</span><span class="p">,</span>
    <span class="n">FixedPoint</span><span class="p">,</span>
    <span class="n">check_and_convert_to_balance</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.btlogging</span> <span class="kn">import</span> <span class="n">logging</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.liquidity</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">calculate_fees</span><span class="p">,</span>
    <span class="n">get_fees</span><span class="p">,</span>
    <span class="n">tick_to_price</span><span class="p">,</span>
    <span class="n">price_to_tick</span><span class="p">,</span>
    <span class="n">LiquidityPosition</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">bittensor.utils.weight_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">generate_weight_hash</span><span class="p">,</span>
    <span class="n">convert_uids_and_weights</span><span class="p">,</span>
    <span class="n">U16_MAX</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">bittensor_wallet</span> <span class="kn">import</span> <span class="n">Wallet</span>
    <span class="kn">from</span> <span class="nn">async_substrate_interface.sync_substrate</span> <span class="kn">import</span> <span class="n">QueryMapResult</span>
    <span class="kn">from</span> <span class="nn">scalecodec.types</span> <span class="kn">import</span> <span class="n">GenericCall</span>


<div class="viewcode-block" id="Subtensor">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor">[docs]</a>
<span class="k">class</span> <span class="nc">Subtensor</span><span class="p">(</span><span class="n">SubtensorMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Thin layer for interacting with Substrate Interface. Mostly a collection of frequently used calls.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">network</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">config</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Config</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">log_verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">fallback_endpoints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">retry_forever</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_mock</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">archive_endpoints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes an instance of the Subtensor class.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            network: The network name or type to connect to.</span>
<span class="sd">            config: Configuration object for the AsyncSubtensor instance.</span>
<span class="sd">            log_verbose: Enables or disables verbose logging.</span>
<span class="sd">            fallback_endpoints: List of fallback endpoints to use if default or provided network is not available.</span>
<span class="sd">                Defaults to `None`.</span>
<span class="sd">            retry_forever: Whether to retry forever on connection errors. Defaults to `False`.</span>
<span class="sd">            _mock: Whether this is a mock instance. Mainly just for use in testing.</span>
<span class="sd">            archive_endpoints: Similar to fallback_endpoints, but specifically only archive nodes. Will be used in cases</span>
<span class="sd">                where you are requesting a block that is too old for your current (presumably lite) node. Defaults to</span>
<span class="sd">                `None`</span>

<span class="sd">        Raises:</span>
<span class="sd">            Any exceptions raised during the setup, configuration, or connection process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_config</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log_verbose</span> <span class="o">=</span> <span class="n">log_verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_and_log_network_settings</span><span class="p">()</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Connecting to network: [blue]</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2">[/blue], &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;chain_endpoint: [blue]</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2">[/blue]&gt; ...&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_substrate</span><span class="p">(</span>
            <span class="n">fallback_endpoints</span><span class="o">=</span><span class="n">fallback_endpoints</span><span class="p">,</span>
            <span class="n">retry_forever</span><span class="o">=</span><span class="n">retry_forever</span><span class="p">,</span>
            <span class="n">_mock</span><span class="o">=</span><span class="n">_mock</span><span class="p">,</span>
            <span class="n">archive_endpoints</span><span class="o">=</span><span class="n">archive_endpoints</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_verbose</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Connected to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2"> network and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<div class="viewcode-block" id="Subtensor.close">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.close">[docs]</a>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Closes the websocket connection.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_get_substrate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fallback_endpoints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">retry_forever</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_mock</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">archive_endpoints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">SubstrateInterface</span><span class="p">,</span> <span class="n">RetrySyncSubstrate</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates the Substrate instance based on provided arguments.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            fallback_endpoints: List of fallback chains endpoints to use if main network isn&#39;t available. Defaults to</span>
<span class="sd">                `None`.</span>
<span class="sd">            retry_forever: Whether to retry forever on connection errors. Defaults to `False`.</span>
<span class="sd">            _mock: Whether this is a mock instance. Mainly just for use in testing.</span>
<span class="sd">            archive_endpoints: Similar to fallback_endpoints, but specifically only archive nodes. Will be used in cases</span>
<span class="sd">                where you are requesting a block that is too old for your current (presumably lite) node. Defaults to</span>
<span class="sd">                `None`</span>

<span class="sd">        Returns:</span>
<span class="sd">            the instance of the SubstrateInterface or RetrySyncSubstrate class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fallback_endpoints</span> <span class="ow">or</span> <span class="n">retry_forever</span> <span class="ow">or</span> <span class="n">archive_endpoints</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RetrySyncSubstrate</span><span class="p">(</span>
                <span class="n">url</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">,</span>
                <span class="n">ss58_format</span><span class="o">=</span><span class="n">SS58_FORMAT</span><span class="p">,</span>
                <span class="n">type_registry</span><span class="o">=</span><span class="n">TYPE_REGISTRY</span><span class="p">,</span>
                <span class="n">use_remote_preset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">chain_name</span><span class="o">=</span><span class="s2">&quot;Bittensor&quot;</span><span class="p">,</span>
                <span class="n">fallback_chains</span><span class="o">=</span><span class="n">fallback_endpoints</span><span class="p">,</span>
                <span class="n">retry_forever</span><span class="o">=</span><span class="n">retry_forever</span><span class="p">,</span>
                <span class="n">_mock</span><span class="o">=</span><span class="n">_mock</span><span class="p">,</span>
                <span class="n">archive_nodes</span><span class="o">=</span><span class="n">archive_endpoints</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">SubstrateInterface</span><span class="p">(</span>
            <span class="n">url</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">,</span>
            <span class="n">ss58_format</span><span class="o">=</span><span class="n">SS58_FORMAT</span><span class="p">,</span>
            <span class="n">type_registry</span><span class="o">=</span><span class="n">TYPE_REGISTRY</span><span class="p">,</span>
            <span class="n">use_remote_preset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">chain_name</span><span class="o">=</span><span class="s2">&quot;Bittensor&quot;</span><span class="p">,</span>
            <span class="n">_mock</span><span class="o">=</span><span class="n">_mock</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Subtensor queries ===========================================================================================</span>

<div class="viewcode-block" id="Subtensor.query_constant">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_constant">[docs]</a>
    <span class="k">def</span> <span class="nf">query_constant</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">module_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">constant_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;ScaleObj&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a constant from the specified module on the Bittensor blockchain. This function is used to access</span>
<span class="sd">            fixed parameters or values defined within the blockchain&#39;s modules, which are essential for understanding</span>
<span class="sd">            the network&#39;s configuration and rules.</span>

<span class="sd">        Args:</span>
<span class="sd">            module_name: The name of the module containing the constant.</span>
<span class="sd">            constant_name: The name of the constant to retrieve.</span>
<span class="sd">            block: The blockchain block number at which to query the constant.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[async_substrate_interface.types.ScaleObj]: The value of the constant if found, `None` otherwise.</span>

<span class="sd">        Constants queried through this function can include critical network parameters such as inflation rates,</span>
<span class="sd">            consensus rules, or validation thresholds, providing a deeper understanding of the Bittensor network&#39;s</span>
<span class="sd">            operational parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span>
            <span class="n">module_name</span><span class="o">=</span><span class="n">module_name</span><span class="p">,</span>
            <span class="n">constant_name</span><span class="o">=</span><span class="n">constant_name</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.query_map">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_map">[docs]</a>
    <span class="k">def</span> <span class="nf">query_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;QueryMapResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries map storage from any module on the Bittensor blockchain. This function retrieves data structures that</span>
<span class="sd">            represent key-value mappings, essential for accessing complex and structured data within the blockchain</span>
<span class="sd">            modules.</span>

<span class="sd">        Args:</span>
<span class="sd">            module: The name of the module from which to query the map storage.</span>
<span class="sd">            name: The specific storage function within the module to query.</span>
<span class="sd">            block: The blockchain block number at which to perform the query.</span>
<span class="sd">            params: Parameters to be passed to the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result: A data structure representing the map storage if found, `None` otherwise.</span>

<span class="sd">        This function is particularly useful for retrieving detailed and structured data from various blockchain</span>
<span class="sd">            modules, offering insights into the network&#39;s state and the relationships between its different components.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Subtensor.query_map_subtensor">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_map_subtensor">[docs]</a>
    <span class="k">def</span> <span class="nf">query_map_subtensor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;QueryMapResult&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries map storage from the Subtensor module on the Bittensor blockchain. This function is designed to retrieve</span>
<span class="sd">            a map-like data structure, which can include various neuron-specific details or network-wide attributes.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: The name of the map storage function to query.</span>
<span class="sd">            block: The blockchain block number at which to perform the query.</span>
<span class="sd">            params: A list of parameters to pass to the query function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An object containing the map-like data structure, or `None` if not found.</span>

<span class="sd">        This function is particularly useful for analyzing and understanding complex network structures and</span>
<span class="sd">            relationships within the Bittensor ecosystem, such as interneuronal connections and stake distributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.query_module">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_module">[docs]</a>
    <span class="k">def</span> <span class="nf">query_module</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ScaleObj&quot;</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">FixedPoint</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries any module storage on the Bittensor blockchain with the specified parameters and block number. This</span>
<span class="sd">            function is a generic query interface that allows for flexible and diverse data retrieval from various</span>
<span class="sd">            blockchain modules.</span>

<span class="sd">        Args:</span>
<span class="sd">            module (str): The name of the module from which to query data.</span>
<span class="sd">            name (str): The name of the storage function within the module.</span>
<span class="sd">            block (Optional[int]): The blockchain block number at which to perform the query.</span>
<span class="sd">            params (Optional[list[object]]): A list of parameters to pass to the query function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An object containing the requested data if found, `None` otherwise.</span>

<span class="sd">        This versatile query function is key to accessing a wide range of data and insights from different parts of the</span>
<span class="sd">            Bittensor blockchain, enhancing the understanding and analysis of the network&#39;s state and dynamics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.query_runtime_api">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_runtime_api">[docs]</a>
    <span class="k">def</span> <span class="nf">query_runtime_api</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">runtime_api</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the runtime API of the Bittensor blockchain, providing a way to interact with the underlying runtime and</span>
<span class="sd">            retrieve data encoded in Scale Bytes format. This function is essential for advanced users who need to</span>
<span class="sd">            interact with specific runtime methods and decode complex data types.</span>

<span class="sd">        Args:</span>
<span class="sd">            runtime_api: The name of the runtime API to query.</span>
<span class="sd">            method: The specific method within the runtime API to call.</span>
<span class="sd">            params: The parameters to pass to the method call.</span>
<span class="sd">            block: the block number for this query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The Scale Bytes encoded result from the runtime API call, or `None` if the call fails.</span>

<span class="sd">        This function enables access to the deeper layers of the Bittensor blockchain, allowing for detailed and</span>
<span class="sd">            specific interactions with the network&#39;s runtime environment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">runtime_call</span><span class="p">(</span><span class="n">runtime_api</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">value</span></div>


<div class="viewcode-block" id="Subtensor.query_subtensor">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_subtensor">[docs]</a>
    <span class="k">def</span> <span class="nf">query_subtensor</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ScaleObj&quot;</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries named storage from the Subtensor module on the Bittensor blockchain. This function is used to retrieve</span>
<span class="sd">            specific data or parameters from the blockchain, such as stake, rank, or other neuron-specific attributes.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: The name of the storage function to query.</span>
<span class="sd">            block: The blockchain block number at which to perform the query.</span>
<span class="sd">            params: A list of parameters to pass to the query function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            query_response: An object containing the requested data.</span>

<span class="sd">        This query function is essential for accessing detailed information about the network and its neurons, providing</span>
<span class="sd">            valuable insights into the state and dynamics of the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.state_call">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.state_call">[docs]</a>
    <span class="k">def</span> <span class="nf">state_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a state call to the Bittensor blockchain, allowing for direct queries of the blockchain&#39;s state. This</span>
<span class="sd">            function is typically used for advanced queries that require specific method calls and data inputs.</span>

<span class="sd">        Args:</span>
<span class="sd">            method: The method name for the state call.</span>
<span class="sd">            data: The data to be passed to the method.</span>
<span class="sd">            block: The blockchain block number at which to perform the state call.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result (dict[Any, Any]): The result of the rpc call.</span>

<span class="sd">        The state call function provides a more direct and flexible way of querying blockchain data, useful for specific</span>
<span class="sd">            use cases where standard queries are insufficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">rpc_request</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;state_call&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">method</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_hash</span> <span class="k">else</span> <span class="p">[</span><span class="n">method</span><span class="p">,</span> <span class="n">data</span><span class="p">],</span>
        <span class="p">)</span></div>


    <span class="c1"># Common subtensor calls ===========================================================================================</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_block</span><span class="p">()</span>

<div class="viewcode-block" id="Subtensor.all_subnets">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.all_subnets">[docs]</a>
    <span class="k">def</span> <span class="nf">all_subnets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="s2">&quot;DynamicInfo&quot;</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the subnet information for all subnets in the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The block number to query the subnet information from.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[DynamicInfo]: A list of DynamicInfo objects, each containing detailed information about a subnet.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">runtime_call</span><span class="p">(</span>
            <span class="n">api</span><span class="o">=</span><span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_all_dynamic_info&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">subnet_prices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subnet_prices</span><span class="p">()</span>
        <span class="n">decoded</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sn</span> <span class="ow">in</span> <span class="n">decoded</span><span class="p">:</span>
            <span class="n">sn</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="n">subnet_prices</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sn</span><span class="p">[</span><span class="s2">&quot;netuid&quot;</span><span class="p">],</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_tao</span><span class="p">(</span><span class="mi">0</span><span class="p">))})</span>
        <span class="k">return</span> <span class="n">DynamicInfo</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">decoded</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.blocks_since_last_step">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.blocks_since_last_step">[docs]</a>
    <span class="k">def</span> <span class="nf">blocks_since_last_step</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns number of blocks since the last epoch of the subnet.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block: the block number for this query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            block number of the last step in the subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;BlocksSinceLastStep&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">query</span></div>


<div class="viewcode-block" id="Subtensor.blocks_since_last_update">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.blocks_since_last_update">[docs]</a>
    <span class="k">def</span> <span class="nf">blocks_since_last_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of blocks since the last update for a specific UID in the subnetwork.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The number of blocks since the last update, or ``None`` if the subnetwork or UID does not</span>
<span class="sd">                exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;LastUpdate&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">call</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_current_block</span><span class="p">()</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">[</span><span class="n">uid</span><span class="p">]))</span></div>


<div class="viewcode-block" id="Subtensor.bonds">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.bonds">[docs]</a>
    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the bond distribution set by neurons within a specific subnet of the Bittensor network.</span>
<span class="sd">            Bonds represent the investments or commitments made by neurons in one another, indicating a level of trust</span>
<span class="sd">            and perceived value. This bonding mechanism is integral to the network&#39;s market-based approach to</span>
<span class="sd">            measuring and rewarding machine intelligence.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid: The network UID of the subnet to query.</span>
<span class="sd">            block: the block number for this query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of tuples mapping each neuron&#39;s UID to its bonds with other neurons.</span>

<span class="sd">        Understanding bond distributions is crucial for analyzing the trust dynamics and market behavior within the</span>
<span class="sd">            subnet. It reflects how neurons recognize and invest in each other&#39;s intelligence and contributions,</span>
<span class="sd">            supporting diverse and niche systems within the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b_map_encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Bonds&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">b_map</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">b_map_encoded</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">b_map</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">uid</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">b_map</span></div>


    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Commits arbitrary data to the Bittensor network by publishing metadata.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron committing the data.</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            data (str): The data to be committed to the network.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: `True` if the commitment was successful, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">publish_metadata</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">data_type</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Raw</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># add explicit alias</span>
    <span class="n">set_commitment</span> <span class="o">=</span> <span class="n">commit</span>

<div class="viewcode-block" id="Subtensor.commit_reveal_enabled">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.commit_reveal_enabled">[docs]</a>
    <span class="k">def</span> <span class="nf">commit_reveal_enabled</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the commit-reveal mechanism is enabled for a given network at a specific block.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid: The network identifier for which to check the commit-reveal mechanism.</span>
<span class="sd">            block: The block number to query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns the integer value of the hyperparameter if available; otherwise, returns None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;CommitRevealWeightsEnabled&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Subtensor.difficulty">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.difficulty">[docs]</a>
    <span class="k">def</span> <span class="nf">difficulty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;Difficulty&#39; hyperparameter for a specified subnet in the Bittensor network.</span>

<span class="sd">        This parameter is instrumental in determining the computational challenge required for neurons to participate in</span>
<span class="sd">            consensus and validation processes.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid: The unique identifier of the subnet.</span>
<span class="sd">            block: The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the &#39;Difficulty&#39; hyperparameter if the subnet exists, ``None`` otherwise.</span>

<span class="sd">        The &#39;Difficulty&#39; parameter directly impacts the network&#39;s security and integrity by setting the computational</span>
<span class="sd">            effort required for validating transactions and participating in the network&#39;s consensus mechanism.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Difficulty&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.does_hotkey_exist">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.does_hotkey_exist">[docs]</a>
    <span class="k">def</span> <span class="nf">does_hotkey_exist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if the hotkey is known by the chain and there are accounts.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58: The SS58 address of the hotkey.</span>
<span class="sd">            block: the block number for this query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the hotkey is known by the chain and there are accounts, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Owner&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">return_val</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">False</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="c1"># not the default key (0x0)</span>
            <span class="k">else</span> <span class="n">result</span> <span class="o">!=</span> <span class="s2">&quot;5C4hrfjw9DjXZTzV3MwzrrAr9P1MJhSrvWGWqi1eSuyUpnhM&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">return_val</span></div>


<div class="viewcode-block" id="Subtensor.get_all_subnets_info">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_all_subnets_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_subnets_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;SubnetInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about all subnets within the Bittensor network. This function provides</span>
<span class="sd">            comprehensive data on each subnet, including its characteristics and operational parameters.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block: The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[SubnetInfo]: A list of SubnetInfo objects, each containing detailed information about a subnet.</span>

<span class="sd">        Gaining insights into the subnets&#39; details assists in understanding the network&#39;s composition, the roles of</span>
<span class="sd">            different subnets, and their unique features.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_subnets_info_v2&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">subnets_prices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subnet_prices</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">subnet</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">subnet</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="n">subnets_prices</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">subnet</span><span class="p">[</span><span class="s2">&quot;netuid&quot;</span><span class="p">],</span> <span class="mi">0</span><span class="p">)})</span>

        <span class="k">return</span> <span class="n">SubnetInfo</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_balance">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_balance">[docs]</a>
    <span class="k">def</span> <span class="nf">get_balance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the balance for given coldkey. Always in TAO.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            address: coldkey address.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Balance object in TAO.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;System&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Account&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">address</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">Balance</span><span class="p">(</span><span class="n">balance</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="s2">&quot;free&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="Subtensor.get_balances">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_balances">[docs]</a>
    <span class="k">def</span> <span class="nf">get_balances</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">addresses</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the balance for given coldkey(s)</span>

<span class="sd">        Arguments:</span>
<span class="sd">            addresses (str): coldkey addresses(s).</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict of {address: Balance objects}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">block_hash</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)):</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_chain_head</span><span class="p">()</span>
        <span class="n">calls</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_storage_key</span><span class="p">(</span>
                    <span class="s2">&quot;System&quot;</span><span class="p">,</span> <span class="s2">&quot;Account&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">address</span><span class="p">],</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">address</span> <span class="ow">in</span> <span class="n">addresses</span>
        <span class="p">]</span>
        <span class="n">batch_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_multi</span><span class="p">(</span><span class="n">calls</span><span class="p">,</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">batch_call</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;free&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}}</span>
            <span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">Balance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="s2">&quot;free&quot;</span><span class="p">])})</span>
        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="Subtensor.get_current_block">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_current_block">[docs]</a>
    <span class="k">def</span> <span class="nf">get_current_block</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the current block number on the Bittensor blockchain. This function provides the latest block number,</span>
<span class="sd">            indicating the most recent state of the blockchain.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The current chain block number.</span>

<span class="sd">        Knowing the current block number is essential for querying real-time data and performing time-sensitive</span>
<span class="sd">            operations on the blockchain. It serves as a reference point for network activities and data</span>
<span class="sd">            synchronization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_number</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span></div>


    <span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_get_block_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>

<div class="viewcode-block" id="Subtensor.get_block_hash">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_block_hash">[docs]</a>
    <span class="k">def</span> <span class="nf">get_block_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the hash of a specific block on the Bittensor blockchain. The block hash is a unique identifier</span>
<span class="sd">            representing the cryptographic hash of the block&#39;s content, ensuring its integrity and immutability.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (int): The block number for which the hash is to be retrieved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The cryptographic hash of the specified block.</span>

<span class="sd">        The block hash is a fundamental aspect of blockchain technology, providing a secure reference to each block&#39;s</span>
<span class="sd">            data. It is crucial for verifying transactions, ensuring data consistency, and maintaining the</span>
<span class="sd">            trustworthiness of the blockchain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">block</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_chain_head</span><span class="p">()</span></div>


<div class="viewcode-block" id="Subtensor.determine_block_hash">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.determine_block_hash">[docs]</a>
    <span class="k">def</span> <span class="nf">determine_block_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">encode_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">call_definition</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;ParamWithTypes&quot;</span><span class="p">]],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a hex encoded string of the params using their types.&quot;&quot;&quot;</span>
        <span class="n">param_data</span> <span class="o">=</span> <span class="n">scalecodec</span><span class="o">.</span><span class="n">ScaleBytes</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">call_definition</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]):</span>
            <span class="n">scale_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_scale_object</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">param_data</span> <span class="o">+=</span> <span class="n">scale_obj</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing param </span><span class="si">{</span><span class="n">param</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> in params dict.&quot;</span><span class="p">)</span>

                <span class="n">param_data</span> <span class="o">+=</span> <span class="n">scale_obj</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">param_data</span><span class="o">.</span><span class="n">to_hex</span><span class="p">()</span>

<div class="viewcode-block" id="Subtensor.get_hyperparameter">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_hyperparameter">[docs]</a>
    <span class="k">def</span> <span class="nf">get_hyperparameter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a specified hyperparameter for a specific subnet.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            param_name (str): The name of the hyperparameter to retrieve.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block: the block number at which to retrieve the hyperparameter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The value of the specified hyperparameter if the subnet exists, or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">subnet_exists</span><span class="p">(</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subnet </span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2"> does not exist&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="n">param_name</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_parents">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_parents">[docs]</a>
    <span class="k">def</span> <span class="nf">get_parents</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method retrieves the parent of a given hotkey and netuid. It queries the SubtensorModule&#39;s ParentKeys</span>
<span class="sd">            storage function to get the children and formats them before returning as a tuple.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey: The child hotkey SS58.</span>
<span class="sd">            netuid: The netuid.</span>
<span class="sd">            block: The block number for which the children are to be retrieved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of formatted parents [(proportion, parent)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;ParentKeys&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">parents</span><span class="p">:</span>
            <span class="n">formatted_parents</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">proportion</span><span class="p">,</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="c1"># Convert U64 to int</span>
                <span class="n">formatted_child</span> <span class="o">=</span> <span class="n">decode_account_id</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">normalized_proportion</span> <span class="o">=</span> <span class="n">u64_normalized_float</span><span class="p">(</span><span class="n">proportion</span><span class="p">)</span>
                <span class="n">formatted_parents</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">normalized_proportion</span><span class="p">,</span> <span class="n">formatted_child</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">formatted_parents</span>

        <span class="k">return</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Subtensor.get_children">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_children">[docs]</a>
    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method retrieves the children of a given hotkey and netuid. It queries the SubtensorModule&#39;s ChildKeys</span>
<span class="sd">            storage function to get the children and formats them before returning as a tuple.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey (str): The hotkey value.</span>
<span class="sd">            netuid (int): The netuid value.</span>
<span class="sd">            block (Optional[int]): The block number for which the children are to be retrieved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple containing a boolean indicating success or failure, a list of formatted children, and an error</span>
<span class="sd">                message (if applicable)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;ChildKeys&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">formatted_children</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">proportion</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="c1"># Convert U64 to int</span>
                    <span class="n">formatted_child</span> <span class="o">=</span> <span class="n">decode_account_id</span><span class="p">(</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">normalized_proportion</span> <span class="o">=</span> <span class="n">u64_normalized_float</span><span class="p">(</span><span class="n">proportion</span><span class="p">)</span>
                    <span class="n">formatted_children</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">normalized_proportion</span><span class="p">,</span> <span class="n">formatted_child</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">formatted_children</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="p">[],</span> <span class="s2">&quot;&quot;</span>
        <span class="k">except</span> <span class="n">SubstrateRequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[],</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_children_pending">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_children_pending">[docs]</a>
    <span class="k">def</span> <span class="nf">get_children_pending</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="nb">int</span><span class="p">,</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method retrieves the pending children of a given hotkey and netuid.</span>
<span class="sd">        It queries the SubtensorModule&#39;s PendingChildKeys storage function.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey (str): The hotkey value.</span>
<span class="sd">            netuid (int): The netuid value.</span>
<span class="sd">            block (Optional[int]): The block number for which the children are to be retrieved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[tuple[float, str]]: A list of children with their proportions.</span>
<span class="sd">            int: The cool-down block number.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">children</span><span class="p">,</span> <span class="n">cooldown</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;PendingChildKeys&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span><span class="o">.</span><span class="n">value</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">u64_normalized_float</span><span class="p">(</span><span class="n">proportion</span><span class="p">),</span>
                    <span class="n">decode_account_id</span><span class="p">(</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">proportion</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span>
            <span class="p">],</span>
            <span class="n">cooldown</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_commitment">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_commitment">[docs]</a>
    <span class="k">def</span> <span class="nf">get_commitment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the on-chain commitment for a specific neuron in the Bittensor network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the commitment from. If None, the latest block is used.</span>
<span class="sd">                Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The commitment data as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metagraph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metagraph</span><span class="p">(</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hotkey</span> <span class="o">=</span> <span class="n">metagraph</span><span class="o">.</span><span class="n">hotkeys</span><span class="p">[</span><span class="n">uid</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Your uid is not in the hotkeys. Please double-check your UID.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

        <span class="n">metadata</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">get_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">,</span> <span class="n">block</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">decode_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>


<div class="viewcode-block" id="Subtensor.get_last_commitment_bonds_reset_block">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_last_commitment_bonds_reset_block">[docs]</a>
    <span class="k">def</span> <span class="nf">get_last_commitment_bonds_reset_block</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the last block number when the bonds reset were triggered by publish_metadata for a specific neuron.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The block number when the bonds were last reset, or None if not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">metagraph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metagraph</span><span class="p">(</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hotkey</span> <span class="o">=</span> <span class="n">metagraph</span><span class="o">.</span><span class="n">hotkeys</span><span class="p">[</span><span class="n">uid</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Your uid is not in the hotkeys. Please double-check your UID.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">get_last_bonds_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">decode_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_all_commitments">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_all_commitments">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_commitments</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Commitments&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CommitmentOf&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">query</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">decode_account_id</span><span class="p">(</span><span class="n">id_</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">decode_metadata</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Subtensor.get_revealed_commitment_by_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_revealed_commitment_by_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_revealed_commitment_by_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">hotkey_ss58_address</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns hotkey related revealed commitment for a given netuid.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            hotkey_ss58_address (str): The ss58 address of the committee member.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the commitment from. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result (tuple[int, str): A tuple of reveal block and commitment message.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_valid_ss58_address</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="n">hotkey_ss58_address</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid ss58 address </span><span class="si">{</span><span class="n">hotkey_ss58_address</span><span class="si">}</span><span class="s2"> provided.&quot;</span><span class="p">)</span>

        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Commitments&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;RevealedCommitments&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58_address</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">decode_revealed_commitment</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">query</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_revealed_commitment">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_revealed_commitment">[docs]</a>
    <span class="k">def</span> <span class="nf">get_revealed_commitment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns uid related revealed commitment for a given netuid.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            uid (int): The neuron uid to retrieve the commitment from.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the commitment from. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result (Optional[tuple[int, str]]: A tuple of reveal block and commitment message.</span>

<span class="sd">        Example of result:</span>
<span class="sd">            ( (12, &quot;Alice message 1&quot;), (152, &quot;Alice message 2&quot;) )</span>
<span class="sd">            ( (12, &quot;Bob message 1&quot;), (147, &quot;Bob message 2&quot;) )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">meta_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_metagraph_info</span><span class="p">(</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">meta_info</span><span class="p">:</span>
                <span class="n">hotkey_ss58_address</span> <span class="o">=</span> <span class="n">meta_info</span><span class="o">.</span><span class="n">hotkeys</span><span class="p">[</span><span class="n">uid</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subnet with netuid </span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subnet </span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2"> does not have a neuron with uid </span><span class="si">{</span><span class="n">uid</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_revealed_commitment_by_hotkey</span><span class="p">(</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58_address</span><span class="o">=</span><span class="n">hotkey_ss58_address</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_all_revealed_commitments">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_all_revealed_commitments">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_revealed_commitments</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns all revealed commitments for a given netuid.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The block number to retrieve the commitment from. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            result (dict): A dictionary of all revealed commitments in view</span>
<span class="sd">                {ss58_address: (reveal block, commitment message)}.</span>

<span class="sd">        Example of result:</span>
<span class="sd">        {</span>
<span class="sd">            &quot;5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY&quot;: ( (12, &quot;Alice message 1&quot;), (152, &quot;Alice message 2&quot;) ),</span>
<span class="sd">            &quot;5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty&quot;: ( (12, &quot;Bob message 1&quot;), (147, &quot;Bob message 2&quot;) ),</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Commitments&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;RevealedCommitments&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">query</span><span class="p">:</span>
            <span class="n">hotkey_ss58_address</span><span class="p">,</span> <span class="n">commitment_message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">decode_revealed_commitment_with_hotkey</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">hotkey_ss58_address</span><span class="p">]</span> <span class="o">=</span> <span class="n">commitment_message</span>
        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span> <span class="nf">get_current_weight_commit_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves CRV3 weight commit information for a specific subnet.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query. Default is ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of commit details, where each entry is a dictionary with keys &#39;who&#39;, &#39;serialized_commit&#39;, and</span>
<span class="sd">            &#39;reveal_round&#39;, or an empty list if no data is found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;CRV3WeightCommits&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="n">commits</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">records</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">records</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">WeightCommitInfo</span><span class="o">.</span><span class="n">from_vec_u8</span><span class="p">(</span><span class="n">commit</span><span class="p">)</span> <span class="k">for</span> <span class="n">commit</span> <span class="ow">in</span> <span class="n">commits</span><span class="p">]</span>

<div class="viewcode-block" id="Subtensor.get_delegate_by_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_delegate_by_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_delegate_by_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;DelegateInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about a delegate neuron based on its hotkey. This function provides a</span>
<span class="sd">            comprehensive view of the delegate&#39;s status, including its stakes, nominators, and reward distribution.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the delegate&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[DelegateInfo]: Detailed information about the delegate neuron, ``None`` if not found.</span>

<span class="sd">        This function is essential for understanding the roles and influence of delegate neurons within the Bittensor</span>
<span class="sd">            network&#39;s consensus and governance structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;DelegateInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_delegate&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">DelegateInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_delegate_identities">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_delegate_identities">[docs]</a>
    <span class="k">def</span> <span class="nf">get_delegate_identities</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ChainIdentity</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches delegates identities from the chain.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict {ss58: ChainIdentity, ...}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">identities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;IdentitiesV2&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="n">decode_account_id</span><span class="p">(</span><span class="n">ss58_address</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="n">ChainIdentity</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
                <span class="n">decode_hex_identity_dict</span><span class="p">(</span><span class="n">identity</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">ss58_address</span><span class="p">,</span> <span class="n">identity</span> <span class="ow">in</span> <span class="n">identities</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="Subtensor.get_delegate_take">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_delegate_take">[docs]</a>
    <span class="k">def</span> <span class="nf">get_delegate_take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the delegate &#39;take&#39; percentage for a neuron identified by its hotkey. The &#39;take&#39; represents the</span>
<span class="sd">            percentage of rewards that the delegate claims from its nominators&#39; stakes.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The delegate take percentage.</span>

<span class="sd">        The delegate take is a critical parameter in the network&#39;s incentive structure, influencing the distribution of</span>
<span class="sd">            rewards among neurons and their nominators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Delegates&quot;</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">u16_normalized_float</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="Subtensor.get_delegated">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_delegated">[docs]</a>
    <span class="k">def</span> <span class="nf">get_delegated</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="s2">&quot;DelegateInfo&quot;</span><span class="p">,</span> <span class="n">Balance</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of delegates and their associated stakes for a given coldkey. This function identifies the</span>
<span class="sd">        delegates that a specific account has staked tokens on.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            coldkey_ss58 (str): The `SS58` address of the account&#39;s coldkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of tuples, each containing a delegate&#39;s information and staked amount.</span>

<span class="sd">        This function is important for account holders to understand their stake allocations and their involvement in</span>
<span class="sd">            the network&#39;s delegation and consensus mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;DelegateInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_delegated&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">coldkey_ss58</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">DelegatedInfo</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_delegates">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_delegates">[docs]</a>
    <span class="k">def</span> <span class="nf">get_delegates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;DelegateInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches all delegates on the chain</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of DelegateInfo objects, or an empty list if there are no delegates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;DelegateInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_delegates&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DelegateInfo</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Subtensor.get_existential_deposit">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_existential_deposit">[docs]</a>
    <span class="k">def</span> <span class="nf">get_existential_deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the existential deposit amount for the Bittensor blockchain. Always in TAO.</span>
<span class="sd">        The existential deposit is the minimum amount of TAO required for an account to exist on the blockchain.</span>
<span class="sd">        Accounts with balances below this threshold can be reaped to conserve network resources.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The existential deposit amount. Always in TAO.</span>

<span class="sd">        The existential deposit is a fundamental economic parameter in the Bittensor network, ensuring efficient use of</span>
<span class="sd">            storage and preventing the proliferation of dust accounts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span>
            <span class="n">module_name</span><span class="o">=</span><span class="s2">&quot;Balances&quot;</span><span class="p">,</span>
            <span class="n">constant_name</span><span class="o">=</span><span class="s2">&quot;ExistentialDeposit&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unable to retrieve existential deposit amount.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.get_hotkey_owner">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_hotkey_owner">[docs]</a>
    <span class="k">def</span> <span class="nf">get_hotkey_owner</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the owner of the given hotkey at a specific block hash.</span>
<span class="sd">        This function queries the blockchain for the owner of the provided hotkey. If the hotkey does not exist at the</span>
<span class="sd">            specified block hash, it returns None.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[str]: The SS58 address of the owner if the hotkey exists, or None if it doesn&#39;t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hk_owner_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Owner&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">exists</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">hk_owner_query</span><span class="p">:</span>
            <span class="n">exists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">does_hotkey_exist</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="n">hotkey_owner</span> <span class="o">=</span> <span class="n">hk_owner_query</span> <span class="k">if</span> <span class="n">exists</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">hotkey_owner</span></div>


<div class="viewcode-block" id="Subtensor.get_minimum_required_stake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_minimum_required_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">get_minimum_required_stake</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the minimum required stake for nominators in the Subtensor network.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The minimum required stake as a Balance object in TAO.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span> <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;NominatorMinRequiredStake&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.get_metagraph_info">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_metagraph_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_metagraph_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">field_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">SelectiveMetagraphIndex</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MetagraphInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves full or partial metagraph information for the specified subnet (netuid).</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid: The NetUID of the subnet to query.</span>
<span class="sd">            field_indices: An optional list of SelectiveMetagraphIndex or int values specifying which fields to retrieve.</span>
<span class="sd">                If not provided, all available fields will be returned.</span>
<span class="sd">            block: The block number at which to query the data. If not specified, the current block or one determined</span>
<span class="sd">                via reuse_block or block_hash will be used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[MetagraphInfo]: A MetagraphInfo object containing the requested subnet data, or None if the subnet</span>
<span class="sd">                with the given netuid does not exist.</span>

<span class="sd">        Example:</span>
<span class="sd">            meta_info = subtensor.get_metagraph_info(netuid=2)</span>

<span class="sd">            partial_meta_info = subtensor.get_metagraph_info(</span>
<span class="sd">                netuid=2,</span>
<span class="sd">                field_indices=[SelectiveMetagraphIndex.Name, SelectiveMetagraphIndex.OwnerHotkeys]</span>
<span class="sd">            )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">field_indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field_indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">SelectiveMetagraphIndex</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_indices</span>
            <span class="p">):</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">SelectiveMetagraphIndex</span><span class="p">)</span> <span class="k">else</span> <span class="n">f</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">field_indices</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;`field_indices` must be a list of SelectiveMetagraphIndex enums or ints.&quot;</span>
                <span class="p">)</span>

            <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">runtime_call</span><span class="p">(</span>
                <span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
                <span class="s2">&quot;get_selective_metagraph&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">indexes</span> <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">indexes</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">indexes</span><span class="p">],</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">runtime_call</span><span class="p">(</span>
                <span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
                <span class="s2">&quot;get_metagraph&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subnet </span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">MetagraphInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_all_metagraphs_info">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_all_metagraphs_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_metagraphs_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">MetagraphInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of MetagraphInfo objects for all subnets</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block: the block number at which to retrieve the hyperparameter. Do not specify if using block_hash or</span>
<span class="sd">                reuse_block</span>

<span class="sd">        Returns:</span>
<span class="sd">            MetagraphInfo dataclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">runtime_call</span><span class="p">(</span>
            <span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="s2">&quot;get_all_metagraphs&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">MetagraphInfo</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_netuids_for_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_netuids_for_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_netuids_for_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of subnet UIDs (netuids) for which a given hotkey is a member. This function identifies the</span>
<span class="sd">            specific subnets within the Bittensor network where the neuron associated with the hotkey is active.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of netuids where the neuron is a member.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;IsNetworkMember&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">netuids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">records</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">record</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">netuids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">netuids</span></div>


<div class="viewcode-block" id="Subtensor.get_neuron_certificate">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_neuron_certificate">[docs]</a>
    <span class="k">def</span> <span class="nf">get_neuron_certificate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Certificate</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the TLS certificate for a specific neuron identified by its unique identifier (UID) within a</span>
<span class="sd">            specified subnet (netuid) of the Bittensor network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey: The hotkey to query.</span>
<span class="sd">            netuid: The unique identifier of the subnet.</span>
<span class="sd">            block: The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the certificate of the neuron if found, `None` otherwise.</span>

<span class="sd">        This function is used for certificate discovery for setting up mutual tls communication between neurons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">certificate_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;NeuronCertificates&quot;</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">certificate_query</span><span class="p">:</span>
                <span class="n">certificate</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">certificate_query</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">Certificate</span><span class="p">(</span><span class="n">certificate</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Subtensor.get_all_neuron_certificates">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_all_neuron_certificates">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_neuron_certificates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Certificate</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the TLS certificates for neurons within a specified subnet (netuid) of the Bittensor network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid: The unique identifier of the subnet.</span>
<span class="sd">            block: The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            {ss58: Certificate} for the key/Certificate pairs on the subnet</span>

<span class="sd">        This function is used for certificate discovery for setting up mutual tls communication between neurons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query_certificates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;NeuronCertificates&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">query_certificates</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="n">decode_account_id</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Certificate</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="Subtensor.get_liquidity_list">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_liquidity_list">[docs]</a>
    <span class="k">def</span> <span class="nf">get_liquidity_list</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">LiquidityPosition</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves all liquidity positions for the given wallet on a specified subnet (netuid).</span>
<span class="sd">        Calculates associated fee rewards based on current global and tick-level fee data.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet: Wallet instance to fetch positions for.</span>
<span class="sd">            netuid: Subnet unique id.</span>
<span class="sd">            block: The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of liquidity positions, or None if subnet does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">subnet_exists</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subnet </span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_subnet_active</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subnet </span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2"> is not active.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="c1"># Fetch global fees and current price</span>
        <span class="n">fee_global_tao_query</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Swap&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;FeeGlobalTao&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fee_global_alpha_query</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Swap&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;FeeGlobalAlpha&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sqrt_price_query</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Swap&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;AlphaSqrtPrice&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fee_global_tao</span> <span class="o">=</span> <span class="n">fixed_to_float</span><span class="p">(</span><span class="n">fee_global_tao_query</span><span class="p">)</span>
        <span class="n">fee_global_alpha</span> <span class="o">=</span> <span class="n">fixed_to_float</span><span class="p">(</span><span class="n">fee_global_alpha_query</span><span class="p">)</span>
        <span class="n">sqrt_price</span> <span class="o">=</span> <span class="n">fixed_to_float</span><span class="p">(</span><span class="n">sqrt_price_query</span><span class="p">)</span>
        <span class="n">current_tick</span> <span class="o">=</span> <span class="n">price_to_tick</span><span class="p">(</span><span class="n">sqrt_price</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Fetch positions</span>
        <span class="n">positions_response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Swap&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Positions&quot;</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">wallet</span><span class="o">.</span><span class="n">coldkeypub</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">positions_response</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">value</span>

            <span class="n">tick_low_idx</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="s2">&quot;tick_low&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">tick_high_idx</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="s2">&quot;tick_high&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">tick_low</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Swap&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Ticks&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">tick_low_idx</span><span class="p">],</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">tick_high</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Swap&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Ticks&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">tick_high_idx</span><span class="p">],</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Calculate fees above/below range for both tokens</span>
            <span class="n">tao_below</span> <span class="o">=</span> <span class="n">get_fees</span><span class="p">(</span>
                <span class="n">current_tick</span><span class="o">=</span><span class="n">current_tick</span><span class="p">,</span>
                <span class="n">tick</span><span class="o">=</span><span class="n">tick_low</span><span class="p">,</span>
                <span class="n">tick_index</span><span class="o">=</span><span class="n">tick_low_idx</span><span class="p">,</span>
                <span class="n">quote</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">global_fees_tao</span><span class="o">=</span><span class="n">fee_global_tao</span><span class="p">,</span>
                <span class="n">global_fees_alpha</span><span class="o">=</span><span class="n">fee_global_alpha</span><span class="p">,</span>
                <span class="n">above</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">tao_above</span> <span class="o">=</span> <span class="n">get_fees</span><span class="p">(</span>
                <span class="n">current_tick</span><span class="o">=</span><span class="n">current_tick</span><span class="p">,</span>
                <span class="n">tick</span><span class="o">=</span><span class="n">tick_high</span><span class="p">,</span>
                <span class="n">tick_index</span><span class="o">=</span><span class="n">tick_high_idx</span><span class="p">,</span>
                <span class="n">quote</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">global_fees_tao</span><span class="o">=</span><span class="n">fee_global_tao</span><span class="p">,</span>
                <span class="n">global_fees_alpha</span><span class="o">=</span><span class="n">fee_global_alpha</span><span class="p">,</span>
                <span class="n">above</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">alpha_below</span> <span class="o">=</span> <span class="n">get_fees</span><span class="p">(</span>
                <span class="n">current_tick</span><span class="o">=</span><span class="n">current_tick</span><span class="p">,</span>
                <span class="n">tick</span><span class="o">=</span><span class="n">tick_low</span><span class="p">,</span>
                <span class="n">tick_index</span><span class="o">=</span><span class="n">tick_low_idx</span><span class="p">,</span>
                <span class="n">quote</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">global_fees_tao</span><span class="o">=</span><span class="n">fee_global_tao</span><span class="p">,</span>
                <span class="n">global_fees_alpha</span><span class="o">=</span><span class="n">fee_global_alpha</span><span class="p">,</span>
                <span class="n">above</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">alpha_above</span> <span class="o">=</span> <span class="n">get_fees</span><span class="p">(</span>
                <span class="n">current_tick</span><span class="o">=</span><span class="n">current_tick</span><span class="p">,</span>
                <span class="n">tick</span><span class="o">=</span><span class="n">tick_high</span><span class="p">,</span>
                <span class="n">tick_index</span><span class="o">=</span><span class="n">tick_high_idx</span><span class="p">,</span>
                <span class="n">quote</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">global_fees_tao</span><span class="o">=</span><span class="n">fee_global_tao</span><span class="p">,</span>
                <span class="n">global_fees_alpha</span><span class="o">=</span><span class="n">fee_global_alpha</span><span class="p">,</span>
                <span class="n">above</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Calculate fees earned by position</span>
            <span class="n">fees_tao</span><span class="p">,</span> <span class="n">fees_alpha</span> <span class="o">=</span> <span class="n">calculate_fees</span><span class="p">(</span>
                <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span>
                <span class="n">global_fees_tao</span><span class="o">=</span><span class="n">fee_global_tao</span><span class="p">,</span>
                <span class="n">global_fees_alpha</span><span class="o">=</span><span class="n">fee_global_alpha</span><span class="p">,</span>
                <span class="n">tao_fees_below_low</span><span class="o">=</span><span class="n">tao_below</span><span class="p">,</span>
                <span class="n">tao_fees_above_high</span><span class="o">=</span><span class="n">tao_above</span><span class="p">,</span>
                <span class="n">alpha_fees_below_low</span><span class="o">=</span><span class="n">alpha_below</span><span class="p">,</span>
                <span class="n">alpha_fees_above_high</span><span class="o">=</span><span class="n">alpha_above</span><span class="p">,</span>
                <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">LiquidityPosition</span><span class="p">(</span>
                    <span class="o">**</span><span class="p">{</span>
                        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">position</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="s2">&quot;price_low&quot;</span><span class="p">:</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_tao</span><span class="p">(</span>
                            <span class="n">tick_to_price</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tick_low&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="p">),</span>
                        <span class="s2">&quot;price_high&quot;</span><span class="p">:</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_tao</span><span class="p">(</span>
                            <span class="n">tick_to_price</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tick_high&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="p">),</span>
                        <span class="s2">&quot;liquidity&quot;</span><span class="p">:</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;liquidity&quot;</span><span class="p">)),</span>
                        <span class="s2">&quot;fees_tao&quot;</span><span class="p">:</span> <span class="n">fees_tao</span><span class="p">,</span>
                        <span class="s2">&quot;fees_alpha&quot;</span><span class="p">:</span> <span class="n">fees_alpha</span><span class="p">,</span>
                        <span class="s2">&quot;netuid&quot;</span><span class="p">:</span> <span class="n">position</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;netuid&quot;</span><span class="p">),</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">positions</span></div>


<div class="viewcode-block" id="Subtensor.get_neuron_for_pubkey_and_subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_neuron_for_pubkey_and_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">get_neuron_for_pubkey_and_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;NeuronInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves information about a neuron based on its public key (hotkey SS58 address) and the specific subnet UID</span>
<span class="sd">            (netuid). This function provides detailed neuron information for a particular subnet within the Bittensor</span>
<span class="sd">            network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[bittensor.core.chain_data.neuron_info.NeuronInfo]: Detailed information about the neuron if found,</span>
<span class="sd">                ``None`` otherwise.</span>

<span class="sd">        This function is crucial for accessing specific neuron data and understanding its status, stake, and other</span>
<span class="sd">            attributes within a particular subnet of the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">uid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Uids&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;NeuronInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_neuron&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">uid</span><span class="o">.</span><span class="n">value</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_next_epoch_start_block">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_next_epoch_start_block">[docs]</a>
    <span class="k">def</span> <span class="nf">get_next_epoch_start_block</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the first block number of the next epoch for the given subnet.</span>

<span class="sd">        If `block` is not provided, the current chain block will be used. Epochs are</span>
<span class="sd">        determined based on the subnet&#39;s tempo (i.e., blocks per epoch). The result</span>
<span class="sd">        is the block number at which the next epoch will begin.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int], optional): The reference block to calculate from.</span>
<span class="sd">                If None, uses the current chain block height.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The block number at which the next epoch will start.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">block</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span>
        <span class="n">blocks_since_last_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_since_last_step</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="n">tempo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tempo</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">block</span> <span class="ow">and</span> <span class="n">blocks_since_last_step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tempo</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">block</span> <span class="o">-</span> <span class="n">blocks_since_last_step</span> <span class="o">+</span> <span class="n">tempo</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Subtensor.get_owned_hotkeys">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_owned_hotkeys">[docs]</a>
    <span class="k">def</span> <span class="nf">get_owned_hotkeys</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reuse_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves all hotkeys owned by a specific coldkey address.</span>

<span class="sd">        Args:</span>
<span class="sd">            coldkey_ss58 (str): The SS58 address of the coldkey to query.</span>
<span class="sd">            block (int): The blockchain block number for the query.</span>
<span class="sd">            reuse_block (bool): Whether to reuse the last-used blockchain block hash.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: A list of hotkey SS58 addresses owned by the coldkey.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">owned_hotkeys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;OwnedHotkeys&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">coldkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">reuse_block_hash</span><span class="o">=</span><span class="n">reuse_block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">decode_account_id</span><span class="p">(</span><span class="n">hotkey</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">hotkey</span> <span class="ow">in</span> <span class="n">owned_hotkeys</span> <span class="ow">or</span> <span class="p">[]]</span></div>


<div class="viewcode-block" id="Subtensor.get_stake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the amount of Alpha staked by a specific coldkey to a specific hotkey within a given subnet.</span>
<span class="sd">        This function retrieves the delegated stake balance, referred to as the &#39;Alpha&#39; value.</span>

<span class="sd">        Args:</span>
<span class="sd">            coldkey_ss58: The SS58 address of the coldkey that delegated the stake. This address owns the stake.</span>
<span class="sd">            hotkey_ss58: The ss58 address of the hotkey which the stake is on.</span>
<span class="sd">            netuid: The unique identifier of the subnet to query.</span>
<span class="sd">            block: The specific block number at which to retrieve the stake information. If None, the current stake at</span>
<span class="sd">                the latest block is returned. Defaults to ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An object representing the amount of Alpha (TAO ONLY if the subnet&#39;s netuid is 0) currently staked from the</span>
<span class="sd">                specified coldkey to the specified hotkey within the given subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha_shares_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Alpha&quot;</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">alpha_shares</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">FixedPoint</span><span class="p">,</span> <span class="n">alpha_shares_query</span><span class="p">)</span>

        <span class="n">hotkey_alpha_obj</span><span class="p">:</span> <span class="n">ScaleObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;TotalHotkeyAlpha&quot;</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">hotkey_alpha</span> <span class="o">=</span> <span class="n">hotkey_alpha_obj</span><span class="o">.</span><span class="n">value</span>

        <span class="n">hotkey_shares_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;TotalHotkeyShares&quot;</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">hotkey_shares</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">FixedPoint</span><span class="p">,</span> <span class="n">hotkey_shares_query</span><span class="p">)</span>

        <span class="n">alpha_shares_as_float</span> <span class="o">=</span> <span class="n">fixed_to_float</span><span class="p">(</span><span class="n">alpha_shares</span><span class="p">)</span>
        <span class="n">hotkey_shares_as_float</span> <span class="o">=</span> <span class="n">fixed_to_float</span><span class="p">(</span><span class="n">hotkey_shares</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hotkey_shares_as_float</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">set_unit</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>

        <span class="n">stake</span> <span class="o">=</span> <span class="n">alpha_shares_as_float</span> <span class="o">/</span> <span class="n">hotkey_shares_as_float</span> <span class="o">*</span> <span class="n">hotkey_alpha</span>

        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">stake</span><span class="p">))</span><span class="o">.</span><span class="n">set_unit</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span></div>


    <span class="c1"># TODO: remove unused parameters in SDK.v10</span>
<div class="viewcode-block" id="Subtensor.get_stake_add_fee">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_stake_add_fee">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stake_add_fee</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the fee for adding new stake to a hotkey.</span>

<span class="sd">        Args:</span>
<span class="sd">            amount: Amount of stake to add in TAO</span>
<span class="sd">            netuid: Netuid of subnet</span>
<span class="sd">            coldkey_ss58: SS58 address of coldkey</span>
<span class="sd">            hotkey_ss58: SS58 address of hotkey</span>
<span class="sd">            block: Block number at which to perform the calculation</span>

<span class="sd">        Returns:</span>
<span class="sd">            The calculated stake fee as a Balance object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stake_operations_fee</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_info">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_subnet_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;SubnetInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about subnet within the Bittensor network.</span>
<span class="sd">        This function provides comprehensive data on subnet, including its characteristics and operational parameters.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid: The unique identifier of the subnet.</span>
<span class="sd">            block: The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SubnetInfo: A SubnetInfo objects, each containing detailed information about a subnet.</span>

<span class="sd">        Gaining insights into the subnet&#39;s details assists in understanding the network&#39;s composition, the roles of</span>
<span class="sd">            different subnets, and their unique features.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_subnet_info_v2&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">SubnetInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_price">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_subnet_price">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_price</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets the current Alpha price in TAO for all subnets.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid: The unique identifier of the subnet.</span>
<span class="sd">            block: The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The current Alpha price in TAO units for the specified subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># SN0 price is always 1 TAO</span>
        <span class="k">if</span> <span class="n">netuid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_tao</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="n">current_sqrt_price</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Swap&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;AlphaSqrtPrice&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">current_sqrt_price</span> <span class="o">=</span> <span class="n">fixed_to_float</span><span class="p">(</span><span class="n">current_sqrt_price</span><span class="p">)</span>
        <span class="n">current_price</span> <span class="o">=</span> <span class="n">current_sqrt_price</span> <span class="o">*</span> <span class="n">current_sqrt_price</span>
        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">current_price</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_prices">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_subnet_prices">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_prices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets the current Alpha price in TAO for a specified subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            block: The blockchain block number for the query. Default to `None`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict:</span>
<span class="sd">                - subnet unique ID</span>
<span class="sd">                - The current Alpha price in TAO units for the specified subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>

        <span class="n">current_sqrt_prices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Swap&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;AlphaSqrtPrice&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
            <span class="n">page_size</span><span class="o">=</span><span class="mi">129</span><span class="p">,</span>  <span class="c1"># total number of subnets</span>
        <span class="p">)</span>

        <span class="n">prices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">current_sqrt_price</span> <span class="ow">in</span> <span class="n">current_sqrt_prices</span><span class="p">:</span>
            <span class="n">current_sqrt_price</span> <span class="o">=</span> <span class="n">fixed_to_float</span><span class="p">(</span><span class="n">current_sqrt_price</span><span class="p">)</span>
            <span class="n">current_price</span> <span class="o">=</span> <span class="n">current_sqrt_price</span> <span class="o">*</span> <span class="n">current_sqrt_price</span>
            <span class="n">current_price_in_tao</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">current_price</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">))</span>
            <span class="n">prices</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">id_</span><span class="p">:</span> <span class="n">current_price_in_tao</span><span class="p">})</span>

        <span class="c1"># SN0 price is always 1 TAO</span>
        <span class="n">prices</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_tao</span><span class="p">(</span><span class="mi">1</span><span class="p">)})</span>
        <span class="k">return</span> <span class="n">prices</span></div>


    <span class="c1"># TODO: remove unused parameters in SDK.v10</span>
<div class="viewcode-block" id="Subtensor.get_unstake_fee">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_unstake_fee">[docs]</a>
    <span class="k">def</span> <span class="nf">get_unstake_fee</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the fee for unstaking from a hotkey.</span>

<span class="sd">        Args:</span>
<span class="sd">            amount: Amount of stake to unstake in TAO</span>
<span class="sd">            netuid: Netuid of subnet</span>
<span class="sd">            coldkey_ss58: SS58 address of coldkey</span>
<span class="sd">            hotkey_ss58: SS58 address of hotkey</span>
<span class="sd">            block: Block number at which to perform the calculation</span>

<span class="sd">        Returns:</span>
<span class="sd">            The calculated stake fee as a Balance object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stake_operations_fee</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span></div>


    <span class="c1"># TODO: remove unused parameters in SDK.v10</span>
<div class="viewcode-block" id="Subtensor.get_stake_movement_fee">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_stake_movement_fee">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stake_movement_fee</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">origin_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">origin_hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">origin_coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">destination_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">destination_hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">destination_coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the fee for moving stake between hotkeys/subnets/coldkeys.</span>

<span class="sd">        Args:</span>
<span class="sd">            amount: Amount of stake to move in TAO</span>
<span class="sd">            origin_netuid: Netuid of origin subnet</span>
<span class="sd">            origin_hotkey_ss58: SS58 address of origin hotkey</span>
<span class="sd">            origin_coldkey_ss58: SS58 address of origin coldkey</span>
<span class="sd">            destination_netuid: Netuid of destination subnet</span>
<span class="sd">            destination_hotkey_ss58: SS58 address of destination hotkey</span>
<span class="sd">            destination_coldkey_ss58: SS58 address of destination coldkey</span>
<span class="sd">            block: Block number at which to perform the calculation</span>

<span class="sd">        Returns:</span>
<span class="sd">            The calculated stake fee as a Balance object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stake_operations_fee</span><span class="p">(</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">origin_netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_stake_for_coldkey_and_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_stake_for_coldkey_and_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stake_for_coldkey_and_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">StakeInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves all coldkey-hotkey pairing stake across specified (or all) subnets</span>

<span class="sd">        Arguments:</span>
<span class="sd">            coldkey_ss58 (str): The SS58 address of the coldkey.</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey.</span>
<span class="sd">            netuids (Optional[list[int]]): The subnet IDs to query for. Set to `None` for all subnets.</span>
<span class="sd">            block (Optional[int]): The block number at which to query the stake information.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A {netuid: StakeInfo} pairing of all stakes across all subnets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">netuids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">all_netuids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subnets</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_netuids</span> <span class="o">=</span> <span class="n">netuids</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
                <span class="s2">&quot;StakeInfoRuntimeApi&quot;</span><span class="p">,</span>
                <span class="s2">&quot;get_stake_info_for_hotkey_coldkey_netuid&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span>
                <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">all_netuids</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">netuid</span><span class="p">:</span> <span class="n">StakeInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">netuid</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_netuids</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
        <span class="p">}</span></div>


    <span class="k">def</span> <span class="nf">get_stake_for_coldkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;StakeInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the stake information for a given coldkey.</span>

<span class="sd">        Args:</span>
<span class="sd">            coldkey_ss58 (str): The SS58 address of the coldkey.</span>
<span class="sd">            block (Optional[int]): The block number at which to query the stake information.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[list[StakeInfo]]: A list of StakeInfo objects, or ``None`` if no stake information is found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;StakeInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_stake_info_for_coldkey&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">coldkey_ss58</span><span class="p">],</span>  <span class="c1"># type: ignore</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">stakes</span> <span class="o">=</span> <span class="n">StakeInfo</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">stake</span> <span class="k">for</span> <span class="n">stake</span> <span class="ow">in</span> <span class="n">stakes</span> <span class="k">if</span> <span class="n">stake</span><span class="o">.</span><span class="n">stake</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">get_stake_info_for_coldkey</span> <span class="o">=</span> <span class="n">get_stake_for_coldkey</span>

<div class="viewcode-block" id="Subtensor.get_stake_for_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_stake_for_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stake_for_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the stake information for a given hotkey.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58: The SS58 address of the hotkey.</span>
<span class="sd">            netuid: The subnet ID to query for.</span>
<span class="sd">            block: The block number at which to query the stake information. Do not specify if also specifying</span>
<span class="sd">                block_hash or reuse_block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hotkey_alpha_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;TotalHotkeyAlpha&quot;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="n">hotkey_alpha</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ScaleObj</span><span class="p">,</span> <span class="n">hotkey_alpha_query</span><span class="p">)</span>
        <span class="n">balance</span> <span class="o">=</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">hotkey_alpha</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">balance</span><span class="o">.</span><span class="n">set_unit</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">balance</span></div>


    <span class="n">get_hotkey_stake</span> <span class="o">=</span> <span class="n">get_stake_for_hotkey</span>

    <span class="k">def</span> <span class="nf">get_stake_operations_fee</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns fee for any stake operation in specified subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            amount: Amount of stake to add in Alpha/TAO.</span>
<span class="sd">            netuid: Netuid of subnet.</span>
<span class="sd">            block: Block number at which to perform the calculation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The calculated stake fee as a Balance object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Swap&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;FeeRate&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">amount</span> <span class="o">*</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="n">U16_MAX</span><span class="p">)</span>

<div class="viewcode-block" id="Subtensor.get_subnet_burn_cost">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_subnet_burn_cost">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_burn_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the burn cost for registering a new subnet within the Bittensor network. This cost represents the</span>
<span class="sd">            amount of Tao that needs to be locked or burned to establish a new subnet.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The burn cost for subnet registration.</span>

<span class="sd">        The subnet burn cost is an important economic parameter, reflecting the network&#39;s mechanisms for controlling</span>
<span class="sd">            the proliferation of subnets and ensuring their commitment to the network&#39;s long-term viability.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lock_cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;SubnetRegistrationRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_network_registration_cost&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">lock_cost</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">lock_cost</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lock_cost</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_hyperparameters">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_subnet_hyperparameters">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_hyperparameters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="s2">&quot;SubnetHyperparameters&quot;</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the hyperparameters for a specific subnet within the Bittensor network. These hyperparameters define</span>
<span class="sd">            the operational settings and rules governing the subnet&#39;s behavior.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The subnet&#39;s hyperparameters, or `None` if not available.</span>

<span class="sd">        Understanding the hyperparameters is crucial for comprehending how subnets are configured and managed, and how</span>
<span class="sd">            they interact with the network&#39;s consensus and incentive mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_subnet_hyperparams_v2&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">SubnetHyperparameters</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_reveal_period_epochs">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_subnet_reveal_period_epochs">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_reveal_period_epochs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve the SubnetRevealPeriodEpochs hyperparameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span>
            <span class="nb">int</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
                <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;RevealPeriodEpochs&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span>
            <span class="p">),</span>
        <span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">get_subnets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the list of all subnet unique identifiers (netuids) currently present in the Bittensor network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of subnet netuids.</span>

<span class="sd">        This function provides a comprehensive view of the subnets within the Bittensor network,</span>
<span class="sd">        offering insights into its diversity and scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;NetworksAdded&quot;</span><span class="p">,</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">subnets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">records</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">exists</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">exists</span><span class="p">:</span>
                    <span class="n">subnets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">netuid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subnets</span>

<div class="viewcode-block" id="Subtensor.get_total_subnets">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_total_subnets">[docs]</a>
    <span class="k">def</span> <span class="nf">get_total_subnets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the total number of subnets within the Bittensor network as of a specific blockchain block.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[str]: The total number of subnets in the network.</span>

<span class="sd">        Understanding the total number of subnets is essential for assessing the network&#39;s growth and the extent of its</span>
<span class="sd">            decentralized infrastructure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;TotalNetworks&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_transfer_fee">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_transfer_fee">[docs]</a>
    <span class="k">def</span> <span class="nf">get_transfer_fee</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Balance</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Balance</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the transaction fee for transferring tokens from a wallet to a specified destination address. This</span>
<span class="sd">            function simulates the transfer to estimate the associated cost, taking into account the current network</span>
<span class="sd">            conditions and transaction complexity.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet from which the transfer is initiated.</span>
<span class="sd">            dest (str): The ``SS58`` address of the destination account.</span>
<span class="sd">            value (Union[bittensor.utils.balance.Balance, float, int]): The amount of tokens to be transferred,</span>
<span class="sd">                specified as a Balance object, or in Tao (float) or Rao (int) units.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bittensor.utils.balance.Balance: The estimated transaction fee for the transfer, represented as a Balance</span>
<span class="sd">                object.</span>

<span class="sd">        Estimating the transfer fee is essential for planning and executing token transactions, ensuring that the wallet</span>
<span class="sd">            has sufficient funds to cover both the transfer amount and the associated costs. This function provides a</span>
<span class="sd">            crucial tool for managing financial operations within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">compose_call</span><span class="p">(</span>
            <span class="n">call_module</span><span class="o">=</span><span class="s2">&quot;Balances&quot;</span><span class="p">,</span>
            <span class="n">call_function</span><span class="o">=</span><span class="s2">&quot;transfer_keep_alive&quot;</span><span class="p">,</span>
            <span class="n">call_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;dest&quot;</span><span class="p">:</span> <span class="n">dest</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">rao</span><span class="p">},</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">payment_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_payment_info</span><span class="p">(</span>
                <span class="n">call</span><span class="o">=</span><span class="n">call</span><span class="p">,</span> <span class="n">keypair</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">coldkeypub</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;:cross_mark: [red]Failed to get payment info: [/red]</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">payment_info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;partial_fee&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2e7</span><span class="p">)}</span>  <span class="c1"># assume  0.02 Tao</span>

        <span class="k">return</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="n">payment_info</span><span class="p">[</span><span class="s2">&quot;partial_fee&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="Subtensor.get_vote_data">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_vote_data">[docs]</a>
    <span class="k">def</span> <span class="nf">get_vote_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">proposal_hash</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;ProposalVoteData&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the voting data for a specific proposal on the Bittensor blockchain. This data includes information</span>
<span class="sd">            about how senate members have voted on the proposal.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            proposal_hash (str): The hash of the proposal for which voting data is requested.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An object containing the proposal&#39;s voting data, or `None` if not found.</span>

<span class="sd">        This function is important for tracking and understanding the decision-making processes within the Bittensor</span>
<span class="sd">            network, particularly how proposals are received and acted upon by the governing body.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vote_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Triumvirate&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Voting&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">proposal_hash</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">vote_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">ProposalVoteData</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">vote_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_uid_for_hotkey_on_subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_uid_for_hotkey_on_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">get_uid_for_hotkey_on_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the unique identifier (UID) for a neuron&#39;s hotkey on a specific subnet.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The UID of the neuron if it is registered on the subnet, ``None`` otherwise.</span>

<span class="sd">        The UID is a critical identifier within the network, linking the neuron&#39;s hotkey to its operational and</span>
<span class="sd">            governance activities on a particular subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Uids&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.filter_netuids_by_registered_hotkeys">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.filter_netuids_by_registered_hotkeys">[docs]</a>
    <span class="k">def</span> <span class="nf">filter_netuids_by_registered_hotkeys</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">all_netuids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">filter_for_netuids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">all_hotkeys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="s2">&quot;Wallet&quot;</span><span class="p">],</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters a given list of all netuids for certain specified netuids and hotkeys</span>

<span class="sd">        Arguments:</span>
<span class="sd">            all_netuids (Iterable[int]): A list of netuids to filter.</span>
<span class="sd">            filter_for_netuids (Iterable[int]): A subset of all_netuids to filter from the main list.</span>
<span class="sd">            all_hotkeys (Iterable[Wallet]): Hotkeys to filter from the main list.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The filtered list of netuids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>  <span class="c1"># just used to cache the block hash</span>
        <span class="n">netuids_with_registered_hotkeys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">item</span>
            <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_netuids_for_hotkey</span><span class="p">(</span>
                    <span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
                    <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">wallet</span> <span class="ow">in</span> <span class="n">all_hotkeys</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">filter_for_netuids</span><span class="p">:</span>
            <span class="n">all_netuids</span> <span class="o">=</span> <span class="n">netuids_with_registered_hotkeys</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">filtered_netuids</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">netuid</span> <span class="k">for</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">all_netuids</span> <span class="k">if</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">filter_for_netuids</span>
            <span class="p">]</span>

            <span class="n">registered_hotkeys_filtered</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">netuid</span>
                <span class="k">for</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">netuids_with_registered_hotkeys</span>
                <span class="k">if</span> <span class="n">netuid</span> <span class="ow">in</span> <span class="n">filter_for_netuids</span>
            <span class="p">]</span>

            <span class="c1"># Combine both filtered lists</span>
            <span class="n">all_netuids</span> <span class="o">=</span> <span class="n">filtered_netuids</span> <span class="o">+</span> <span class="n">registered_hotkeys_filtered</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_netuids</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.immunity_period">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.immunity_period">[docs]</a>
    <span class="k">def</span> <span class="nf">immunity_period</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;ImmunityPeriod&#39; hyperparameter for a specific subnet. This parameter defines the duration during</span>
<span class="sd">            which new neurons are protected from certain network penalties or restrictions.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the &#39;ImmunityPeriod&#39; hyperparameter if the subnet exists, ``None`` otherwise.</span>

<span class="sd">        The &#39;ImmunityPeriod&#39; is a critical aspect of the network&#39;s governance system, ensuring that new participants</span>
<span class="sd">            have a grace period to establish themselves and contribute to the network without facing immediate</span>
<span class="sd">            punitive actions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;ImmunityPeriod&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.is_fast_blocks">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.is_fast_blocks">[docs]</a>
    <span class="k">def</span> <span class="nf">is_fast_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the node is running with fast blocks. False if not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_constant</span><span class="p">(</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span> <span class="s2">&quot;DurationOfStartCall&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">10</span></div>


<div class="viewcode-block" id="Subtensor.is_hotkey_delegate">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.is_hotkey_delegate">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_delegate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines whether a given hotkey (public key) is a delegate on the Bittensor network. This function checks if</span>
<span class="sd">            the neuron associated with the hotkey is part of the network&#39;s delegation system.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the hotkey is a delegate, `False` otherwise.</span>

<span class="sd">        Being a delegate is a significant status within the Bittensor network, indicating a neuron&#39;s involvement in</span>
<span class="sd">            consensus and governance processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">delegates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_delegates</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hotkey_ss58</span> <span class="ow">in</span> <span class="p">[</span><span class="n">info</span><span class="o">.</span><span class="n">hotkey_ss58</span> <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">delegates</span><span class="p">]</span></div>


<div class="viewcode-block" id="Subtensor.is_hotkey_registered">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.is_hotkey_registered">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_registered</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines whether a given hotkey (public key) is registered in the Bittensor network, either globally across</span>
<span class="sd">            any subnet or specifically on a specified subnet. This function checks the registration status of a neuron</span>
<span class="sd">            identified by its hotkey, which is crucial for validating its participation and activities within the</span>
<span class="sd">            network.</span>

<span class="sd">        Args:</span>
<span class="sd">            hotkey_ss58: The SS58 address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid: The unique identifier of the subnet to check the registration. If `None`, the</span>
<span class="sd">                registration is checked across all subnets.</span>
<span class="sd">            block: The blockchain block number at which to perform the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: `True` if the hotkey is registered in the specified context (either any subnet or a specific subnet),</span>
<span class="sd">                `False` otherwise.</span>

<span class="sd">        This function is important for verifying the active status of neurons in the Bittensor network. It aids in</span>
<span class="sd">            understanding whether a neuron is eligible to participate in network processes such as consensus,</span>
<span class="sd">            validation, and incentive distribution based on its registration status.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">netuid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hotkey_registered_any</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hotkey_registered_on_subnet</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.is_hotkey_registered_any">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.is_hotkey_registered_any">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_registered_any</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a neuron&#39;s hotkey is registered on any subnet within the Bittensor network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the hotkey is registered on any subnet, False otherwise.</span>

<span class="sd">        This function is essential for determining the network-wide presence and participation of a neuron.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hotkeys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_netuids_for_hotkey</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">hotkeys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Subtensor.is_hotkey_registered_on_subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.is_hotkey_registered_on_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">is_hotkey_registered_on_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if the hotkey is registered on a given netuid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_uid_for_hotkey_on_subnet</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">,</span> <span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.is_subnet_active">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.is_subnet_active">[docs]</a>
    <span class="k">def</span> <span class="nf">is_subnet_active</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Verify if subnet with provided netuid is active.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if subnet is active, False otherwise.</span>

<span class="sd">        This means whether the `start_call` was initiated or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;FirstEmissionBlockNumber&quot;</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">query</span> <span class="ow">and</span> <span class="n">query</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Subtensor.last_drand_round">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.last_drand_round">[docs]</a>
    <span class="k">def</span> <span class="nf">last_drand_round</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the last drand round emitted in bittensor. This corresponds when committed weights will be revealed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The latest Drand round emitted in bittensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;Drand&quot;</span><span class="p">,</span> <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;LastStoredRound&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.max_weight_limit">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.max_weight_limit">[docs]</a>
    <span class="k">def</span> <span class="nf">max_weight_limit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network MaxWeightsLimit hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[float]: The value of the MaxWeightsLimit hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;MaxWeightsLimit&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">u16_normalized_float</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.metagraph">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.metagraph">[docs]</a>
    <span class="k">def</span> <span class="nf">metagraph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">lite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Metagraph&quot;</span><span class="p">:</span>
        <span class="n">metagraph</span> <span class="o">=</span> <span class="n">Metagraph</span><span class="p">(</span>
            <span class="n">network</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_endpoint</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">lite</span><span class="o">=</span><span class="n">lite</span><span class="p">,</span>
            <span class="n">sync</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">metagraph</span><span class="o">.</span><span class="n">sync</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">lite</span><span class="o">=</span><span class="n">lite</span><span class="p">,</span> <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">metagraph</span></div>


<div class="viewcode-block" id="Subtensor.min_allowed_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.min_allowed_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">min_allowed_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network MinAllowedWeights hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the MinAllowedWeights hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;MinAllowedWeights&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.neuron_for_uid">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.neuron_for_uid">[docs]</a>
    <span class="k">def</span> <span class="nf">neuron_for_uid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">uid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;NeuronInfo&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves detailed information about a specific neuron identified by its unique identifier (UID) within a</span>
<span class="sd">            specified subnet (netuid) of the Bittensor network. This function provides a comprehensive view of a</span>
<span class="sd">            neuron&#39;s attributes, including its stake, rank, and operational status.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            uid (int): The unique identifier of the neuron.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Detailed information about the neuron if found, a null neuron otherwise</span>

<span class="sd">        This function is crucial for analyzing individual neurons&#39; contributions and status within a specific subnet,</span>
<span class="sd">            offering insights into their roles in the network&#39;s consensus and validation mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;NeuronInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_neuron&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">,</span> <span class="n">uid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">get_null_neuron</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.neurons">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.neurons">[docs]</a>
    <span class="k">def</span> <span class="nf">neurons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;NeuronInfo&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of all neurons within a specified subnet of the Bittensor network.</span>
<span class="sd">        This function provides a snapshot of the subnet&#39;s neuron population, including each neuron&#39;s attributes and</span>
<span class="sd">            network interactions.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of NeuronInfo objects detailing each neuron&#39;s characteristics in the subnet.</span>

<span class="sd">        Understanding the distribution and status of neurons within a subnet is key to comprehending the network&#39;s</span>
<span class="sd">            decentralized structure and the dynamics of its consensus and governance processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;NeuronInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_neurons&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">NeuronInfo</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.neurons_lite">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.neurons_lite">[docs]</a>
    <span class="k">def</span> <span class="nf">neurons_lite</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;NeuronInfoLite&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a list of neurons in a &#39;lite&#39; format from a specific subnet of the Bittensor network.</span>
<span class="sd">        This function provides a streamlined view of the neurons, focusing on key attributes such as stake and network</span>
<span class="sd">            participation.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of simplified neuron information for the subnet.</span>

<span class="sd">        This function offers a quick overview of the neuron population within a subnet, facilitating efficient analysis</span>
<span class="sd">            of the network&#39;s decentralized structure and neuron dynamics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_runtime_api</span><span class="p">(</span>
            <span class="n">runtime_api</span><span class="o">=</span><span class="s2">&quot;NeuronInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_neurons_lite&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">NeuronInfoLite</span><span class="o">.</span><span class="n">list_from_dicts</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.query_identity">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.query_identity">[docs]</a>
    <span class="k">def</span> <span class="nf">query_identity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ChainIdentity</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the identity of a neuron on the Bittensor blockchain using the given key. This function retrieves</span>
<span class="sd">            detailed identity information about a specific neuron, which is a crucial aspect of the network&#39;s</span>
<span class="sd">            decentralized identity and governance system.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            coldkey_ss58 (str): The coldkey used to query the neuron&#39;s identity (technically the neuron&#39;s coldkey SS58</span>
<span class="sd">                address).</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An object containing the identity information of the neuron if found, ``None`` otherwise.</span>

<span class="sd">        The identity information can include various attributes such as the neuron&#39;s stake, rank, and other</span>
<span class="sd">            network-specific details, providing insights into the neuron&#39;s role and status within the Bittensor network.</span>

<span class="sd">        Note:</span>
<span class="sd">            See the `Bittensor CLI documentation &lt;https://docs.bittensor.com/reference/btcli&gt;`_ for supported identity</span>
<span class="sd">                parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">identity_info</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
                <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;IdentitiesV2&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">coldkey_ss58</span><span class="p">],</span>
                <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">identity_info</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ChainIdentity</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
                <span class="n">decode_hex_identity_dict</span><span class="p">(</span><span class="n">identity_info</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Subtensor.recycle">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.recycle">[docs]</a>
    <span class="k">def</span> <span class="nf">recycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Balance</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the &#39;Burn&#39; hyperparameter for a specified subnet. The &#39;Burn&#39; parameter represents the amount of Tao</span>
<span class="sd">            that is effectively recycled within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[Balance]: The value of the &#39;Burn&#39; hyperparameter if the subnet exists, None otherwise.</span>

<span class="sd">        Understanding the &#39;Burn&#39; rate is essential for analyzing the network registration usage, particularly how it is</span>
<span class="sd">            correlated with user activity and the overall cost of participation in a given subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Burn&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Balance</span><span class="o">.</span><span class="n">from_rao</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">))</span></div>


<div class="viewcode-block" id="Subtensor.set_reveal_commitment">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.set_reveal_commitment">[docs]</a>
    <span class="k">def</span> <span class="nf">set_reveal_commitment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">blocks_until_reveal</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">360</span><span class="p">,</span>
        <span class="n">block_time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Commits arbitrary data to the Bittensor network by publishing metadata.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron committing the data.</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            data (str): The data to be committed to the network.</span>
<span class="sd">            blocks_until_reveal (int): The number of blocks from now after which the data will be revealed. Defaults to</span>
<span class="sd">                `360`. Then number of blocks in one epoch.</span>
<span class="sd">            block_time (Union[int, float]): The number of seconds between each block. Defaults to `12`.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>
<span class="sd">        Returns:</span>
<span class="sd">            bool: `True` if the commitment was successful, `False` otherwise.</span>

<span class="sd">        Note: A commitment can be set once per subnet epoch and is reset at the next epoch in the chain automatically.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">encrypted</span><span class="p">,</span> <span class="n">reveal_round</span> <span class="o">=</span> <span class="n">get_encrypted_commitment</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">blocks_until_reveal</span><span class="p">,</span> <span class="n">block_time</span>
        <span class="p">)</span>

        <span class="c1"># increase reveal_round in return + 1 because we want to fetch data from the chain after that round was revealed</span>
        <span class="c1"># and stored.</span>
        <span class="n">data_</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;encrypted&quot;</span><span class="p">:</span> <span class="n">encrypted</span><span class="p">,</span> <span class="s2">&quot;reveal_round&quot;</span><span class="p">:</span> <span class="n">reveal_round</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">publish_metadata</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;TimelockEncrypted&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data_</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">),</span> <span class="n">reveal_round</span></div>


<div class="viewcode-block" id="Subtensor.subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">subnet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DynamicInfo</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the subnet information for a single subnet in the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The block number to query the subnet information from.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[DynamicInfo]: A DynamicInfo object, containing detailed information about a subnet.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>

        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">runtime_call</span><span class="p">(</span>
            <span class="n">api</span><span class="o">=</span><span class="s2">&quot;SubnetInfoRuntimeApi&quot;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;get_dynamic_info&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decoded</span> <span class="o">:=</span> <span class="n">query</span><span class="o">.</span><span class="n">decode</span><span class="p">(),</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">price</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subnet_price</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">SubstrateRequestException</span><span class="p">:</span>
                <span class="n">price</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">DynamicInfo</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({</span><span class="o">**</span><span class="n">decoded</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="n">price</span><span class="p">})</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Subtensor.subnet_exists">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.subnet_exists">[docs]</a>
    <span class="k">def</span> <span class="nf">subnet_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a subnet with the specified unique identifier (netuid) exists within the Bittensor network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the subnet exists, `False` otherwise.</span>

<span class="sd">        This function is critical for verifying the presence of specific subnets in the network,</span>
<span class="sd">        enabling a deeper understanding of the network&#39;s structure and composition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;NetworksAdded&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.subnetwork_n">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.subnetwork_n">[docs]</a>
    <span class="k">def</span> <span class="nf">subnetwork_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network SubnetworkN hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the SubnetworkN hyperparameter, or ``None`` if the subnetwork does not exist or</span>
<span class="sd">                the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;SubnetworkN&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.tempo">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.tempo">[docs]</a>
    <span class="k">def</span> <span class="nf">tempo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network Tempo hyperparameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the Tempo hyperparameter, or ``None`` if the subnetwork does not exist or the</span>
<span class="sd">                parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span><span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;Tempo&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.tx_rate_limit">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.tx_rate_limit">[docs]</a>
    <span class="k">def</span> <span class="nf">tx_rate_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the transaction rate limit for the Bittensor network as of a specific blockchain block.</span>
<span class="sd">        This rate limit sets the maximum number of transactions that can be processed within a given time frame.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The transaction rate limit of the network, None if not available.</span>

<span class="sd">        The transaction rate limit is an essential parameter for ensuring the stability and scalability of the Bittensor</span>
<span class="sd">            network. It helps in managing network load and preventing congestion, thereby maintaining efficient and</span>
<span class="sd">            timely transaction processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span><span class="s2">&quot;TxRateLimit&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.wait_for_block">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.wait_for_block">[docs]</a>
    <span class="k">def</span> <span class="nf">wait_for_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Waits until a specific block is reached on the chain. If no block is specified,</span>
<span class="sd">        waits for the next block.</span>

<span class="sd">        Args:</span>
<span class="sd">            block (Optional[int]): The block number to wait for. If None, waits for the next block.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the target block was reached, False if timeout occurred.</span>

<span class="sd">        Example:</span>
<span class="sd">            import bittensor as bt</span>
<span class="sd">            subtensor = bt.Subtensor()</span>

<span class="sd">            subtensor.wait_for_block() # Waits for the next block</span>
<span class="sd">            subtensor.wait_for_block(block=1234) # Waits for a specific block</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">block_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;reached block </span><span class="si">{</span><span class="n">block_data</span><span class="p">[</span><span class="s1">&#39;header&#39;</span><span class="p">][</span><span class="s1">&#39;number&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">. Waiting for block </span><span class="si">{</span><span class="n">target_block</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">block_data</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">][</span><span class="s2">&quot;number&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">target_block</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">current_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block</span><span class="p">()</span>
        <span class="n">current_block_hash</span> <span class="o">=</span> <span class="n">current_block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;hash&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">target_block</span> <span class="o">=</span> <span class="n">block</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_block</span> <span class="o">=</span> <span class="n">current_block</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">][</span><span class="s2">&quot;number&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_block_handler</span><span class="p">(</span>
            <span class="n">current_block_hash</span><span class="p">,</span> <span class="n">header_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subscription_handler</span><span class="o">=</span><span class="n">handler</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Subtensor.weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.weights">[docs]</a>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the weight distribution set by neurons within a specific subnet of the Bittensor network.</span>
<span class="sd">        This function maps each neuron&#39;s UID to the weights it assigns to other neurons, reflecting the network&#39;s trust</span>
<span class="sd">            and value assignment mechanisms.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The network UID of the subnet to query.</span>
<span class="sd">            block (Optional[int]): Block number for synchronization, or ``None`` for the latest block.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of tuples mapping each neuron&#39;s UID to its assigned weights.</span>

<span class="sd">        The weight distribution is a key factor in the network&#39;s consensus algorithm and the ranking of neurons,</span>
<span class="sd">            influencing their influence and reward allocation within the subnet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">w_map_encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">query_map</span><span class="p">(</span>
            <span class="n">module</span><span class="o">=</span><span class="s2">&quot;SubtensorModule&quot;</span><span class="p">,</span>
            <span class="n">storage_function</span><span class="o">=</span><span class="s2">&quot;Weights&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_block_hash</span><span class="p">(</span><span class="n">block</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">w_map</span> <span class="o">=</span> <span class="p">[(</span><span class="n">uid</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">value</span> <span class="ow">or</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_map_encoded</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">w_map</span></div>


<div class="viewcode-block" id="Subtensor.weights_rate_limit">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.weights_rate_limit">[docs]</a>
    <span class="k">def</span> <span class="nf">weights_rate_limit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns network WeightsSetRateLimit hyperparameter.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            block (Optional[int]): The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[int]: The value of the WeightsSetRateLimit hyperparameter, or ``None`` if the subnetwork does not</span>
<span class="sd">                exist or the parameter is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hyperparameter</span><span class="p">(</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;WeightsSetRateLimit&quot;</span><span class="p">,</span> <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">call</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_timestamp">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_timestamp">[docs]</a>
    <span class="k">def</span> <span class="nf">get_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the datetime timestamp for a given block</span>

<span class="sd">        Arguments:</span>
<span class="sd">            block: The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            datetime object for the timestamp of the block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unix</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ScaleObj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_module</span><span class="p">(</span><span class="s2">&quot;Timestamp&quot;</span><span class="p">,</span> <span class="s2">&quot;Now&quot;</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">))</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">fromtimestamp</span><span class="p">(</span><span class="n">unix</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_owner_hotkey">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_subnet_owner_hotkey">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_owner_hotkey</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the hotkey of the subnet owner for a given network UID.</span>

<span class="sd">        This function queries the subtensor network to fetch the hotkey of the owner of a subnet specified by its</span>
<span class="sd">        netuid. If no data is found or the query fails, the function returns None.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid: The network UID of the subnet to fetch the owner&#39;s hotkey for.</span>
<span class="sd">            block: The specific block number to query the data from.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The hotkey of the subnet owner if available; None otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;SubnetOwnerHotkey&quot;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.get_subnet_validator_permits">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.get_subnet_validator_permits">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subnet_validator_permits</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the list of validator permits for a given subnet as boolean values.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            netuid: The unique identifier of the subnetwork.</span>
<span class="sd">            block: The blockchain block number for the query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of boolean values representing validator permits, or None if not available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_subtensor</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ValidatorPermit&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">netuid</span><span class="p">],</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">query</span></div>


    <span class="c1"># Extrinsics helper ================================================================================================</span>

<div class="viewcode-block" id="Subtensor.sign_and_send_extrinsic">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.sign_and_send_extrinsic">[docs]</a>
    <span class="k">def</span> <span class="nf">sign_and_send_extrinsic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">call</span><span class="p">:</span> <span class="s2">&quot;GenericCall&quot;</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sign_with</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;coldkey&quot;</span><span class="p">,</span>
        <span class="n">use_nonce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nonce_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hotkey&quot;</span><span class="p">,</span>
        <span class="n">raise_error</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to sign and submit an extrinsic call to chain.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            call (scalecodec.types.GenericCall): a prepared Call object</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): the wallet whose coldkey will be used to sign the extrinsic</span>
<span class="sd">            wait_for_inclusion (bool): whether to wait until the extrinsic call is included on the chain</span>
<span class="sd">            wait_for_finalization (bool): whether to wait until the extrinsic call is finalized on the chain</span>
<span class="sd">            sign_with (str): the wallet&#39;s keypair to use for the signing. Options are &quot;coldkey&quot;, &quot;hotkey&quot;, &quot;coldkeypub&quot;</span>
<span class="sd">            use_nonce (bool): unique identifier for the transaction related with hot/coldkey.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>
<span class="sd">            nonce_key: the type on nonce to use. Options are &quot;hotkey&quot; or &quot;coldkey&quot;.</span>
<span class="sd">            raise_error: raises the relevant exception rather than returning `False` if unsuccessful.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (success, error message)</span>

<span class="sd">        Raises:</span>
<span class="sd">            SubstrateRequestException: Substrate request exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">possible_keys</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;coldkey&quot;</span><span class="p">,</span> <span class="s2">&quot;hotkey&quot;</span><span class="p">,</span> <span class="s2">&quot;coldkeypub&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sign_with</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">possible_keys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;sign_with&#39; must be either &#39;coldkey&#39;, &#39;hotkey&#39; or &#39;coldkeypub&#39;, not &#39;</span><span class="si">{</span><span class="n">sign_with</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

        <span class="n">signing_keypair</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">wallet</span><span class="p">,</span> <span class="n">sign_with</span><span class="p">)</span>
        <span class="n">extrinsic_data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;call&quot;</span><span class="p">:</span> <span class="n">call</span><span class="p">,</span> <span class="s2">&quot;keypair&quot;</span><span class="p">:</span> <span class="n">signing_keypair</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">use_nonce</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nonce_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">possible_keys</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;nonce_key&#39; must be either &#39;coldkey&#39;, &#39;hotkey&#39; or &#39;coldkeypub&#39;, not &#39;</span><span class="si">{</span><span class="n">nonce_key</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                <span class="p">)</span>
            <span class="n">next_nonce</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">get_account_next_index</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">wallet</span><span class="p">,</span> <span class="n">nonce_key</span><span class="p">)</span><span class="o">.</span><span class="n">ss58_address</span>
            <span class="p">)</span>
            <span class="n">extrinsic_data</span><span class="p">[</span><span class="s2">&quot;nonce&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_nonce</span>
        <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrinsic_data</span><span class="p">[</span><span class="s2">&quot;era&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;period&quot;</span><span class="p">:</span> <span class="n">period</span><span class="p">}</span>

        <span class="n">extrinsic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">create_signed_extrinsic</span><span class="p">(</span><span class="o">**</span><span class="n">extrinsic_data</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substrate</span><span class="o">.</span><span class="n">submit_extrinsic</span><span class="p">(</span>
                <span class="n">extrinsic</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># We only wait here if we expect finalization.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wait_for_finalization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wait_for_inclusion</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Not waiting for finalization or inclusion.&quot;</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">. Extrinsic: </span><span class="si">{</span><span class="n">extrinsic</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">message</span>

            <span class="k">if</span> <span class="n">response</span><span class="o">.</span><span class="n">is_success</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>

            <span class="k">if</span> <span class="n">raise_error</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ChainError</span><span class="o">.</span><span class="n">from_error</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">error_message</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">SubstrateRequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">raise_error</span><span class="p">:</span>
                <span class="k">raise</span>

            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">format_error_message</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div>


    <span class="c1"># Extrinsics =======================================================================================================</span>

<div class="viewcode-block" id="Subtensor.add_stake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.add_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">add_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Balance</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">safe_staking</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_partial_stake</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">rate_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a stake from the specified wallet to the neuron identified by the SS58 address of its hotkey in specified</span>
<span class="sd">            subnet. Staking is a fundamental process in the Bittensor network that enables neurons to participate</span>
<span class="sd">            actively and earn incentives.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet: The wallet to be used for staking.</span>
<span class="sd">            hotkey_ss58: The SS58 address of the hotkey associated with the neuron to which you intend to delegate your</span>
<span class="sd">                stake. If not specified, the wallet&#39;s hotkey will be used. Defaults to ``None``.</span>
<span class="sd">            netuid: The unique identifier of the subnet to which the neuron belongs.</span>
<span class="sd">            amount: The amount of TAO to stake.</span>
<span class="sd">            wait_for_inclusion: Waits for the transaction to be included in a block. Defaults to ``True``.</span>
<span class="sd">            wait_for_finalization: Waits for the transaction to be finalized on the blockchain. Defaults to ``False``.</span>
<span class="sd">            safe_staking: If true, enables price safety checks to protect against fluctuating prices. The stake will</span>
<span class="sd">                only execute if the price change doesn&#39;t exceed the rate tolerance. Default is ``False``.</span>
<span class="sd">            allow_partial_stake: If true and safe_staking is enabled, allows partial staking when the full amount would</span>
<span class="sd">                exceed the price tolerance. If false, the entire stake fails if it would exceed the tolerance.</span>
<span class="sd">                Default is ``False``.</span>
<span class="sd">            rate_tolerance: The maximum allowed price change ratio when staking. For example,</span>
<span class="sd">                0.005 = 0.5% maximum price increase. Only used when safe_staking is True. Default is ``0.005``.</span>
<span class="sd">            period: The number of blocks during which the transaction will remain valid after it&#39;s submitted. If the</span>
<span class="sd">                transaction is not included in a block within that number of blocks, it will expire and be rejected. You</span>
<span class="sd">                can think of it as an expiration date for the transaction. Defaults to ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the staking is successful, False otherwise.</span>

<span class="sd">        This function enables neurons to increase their stake in the network, enhancing their influence and potential</span>
<span class="sd">            rewards in line with Bittensor&#39;s consensus and reward mechanisms.</span>
<span class="sd">            When safe_staking is enabled, it provides protection against price fluctuations during the time stake is</span>
<span class="sd">            executed and the time it is actually processed by the chain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">add_stake_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58</span><span class="o">=</span><span class="n">hotkey_ss58</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">safe_staking</span><span class="o">=</span><span class="n">safe_staking</span><span class="p">,</span>
            <span class="n">allow_partial_stake</span><span class="o">=</span><span class="n">allow_partial_stake</span><span class="p">,</span>
            <span class="n">rate_tolerance</span><span class="o">=</span><span class="n">rate_tolerance</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.add_liquidity">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.add_liquidity">[docs]</a>
    <span class="k">def</span> <span class="nf">add_liquidity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">liquidity</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">price_low</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">price_high</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">hotkey</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds liquidity to the specified price range.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet: The wallet used to sign the extrinsic (must be unlocked).</span>
<span class="sd">            netuid: The UID of the target subnet for which the call is being initiated.</span>
<span class="sd">            liquidity: The amount of liquidity to be added.</span>
<span class="sd">            price_low: The lower bound of the price tick range. In TAO.</span>
<span class="sd">            price_high: The upper bound of the price tick range. In TAO.</span>
<span class="sd">            hotkey: The hotkey with staked TAO in Alpha. If not passed then the wallet hotkey is used. Defaults to</span>
<span class="sd">                `None`.</span>
<span class="sd">            wait_for_inclusion: Whether to wait for the extrinsic to be included in a block. Defaults to True.</span>
<span class="sd">            wait_for_finalization: Whether to wait for finalization of the extrinsic. Defaults to False.</span>
<span class="sd">            period: The number of blocks during which the transaction will remain valid after it&#39;s submitted. If</span>
<span class="sd">                the transaction is not included in a block within that number of blocks, it will expire and be rejected.</span>
<span class="sd">                You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, str]:</span>
<span class="sd">                - True and a success message if the extrinsic is successfully submitted or processed.</span>
<span class="sd">                - False and an error message if the submission fails or the wallet cannot be unlocked.</span>

<span class="sd">        Note: Adding is allowed even when user liquidity is enabled in specified subnet. Call `toggle_user_liquidity`</span>
<span class="sd">            method to enable/disable user liquidity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">add_liquidity_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">liquidity</span><span class="o">=</span><span class="n">liquidity</span><span class="p">,</span>
            <span class="n">price_low</span><span class="o">=</span><span class="n">price_low</span><span class="p">,</span>
            <span class="n">price_high</span><span class="o">=</span><span class="n">price_high</span><span class="p">,</span>
            <span class="n">hotkey</span><span class="o">=</span><span class="n">hotkey</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.add_stake_multiple">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.add_stake_multiple">[docs]</a>
    <span class="k">def</span> <span class="nf">add_stake_multiple</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58s</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">netuids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">amounts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Balance</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds stakes to multiple neurons identified by their hotkey SS58 addresses.</span>
<span class="sd">        This bulk operation allows for efficient staking across different neurons from a single wallet.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet used for staking.</span>
<span class="sd">            hotkey_ss58s (list[str]): List of ``SS58`` addresses of hotkeys to stake to.</span>
<span class="sd">            netuids (list[int]): List of network UIDs to stake to.</span>
<span class="sd">            amounts (list[Balance]): Corresponding amounts of TAO to stake for each hotkey.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the staking is successful for all specified neurons, False otherwise.</span>

<span class="sd">        This function is essential for managing stakes across multiple neurons, reflecting the dynamic and collaborative</span>
<span class="sd">            nature of the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">add_stake_multiple_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58s</span><span class="o">=</span><span class="n">hotkey_ss58s</span><span class="p">,</span>
            <span class="n">netuids</span><span class="o">=</span><span class="n">netuids</span><span class="p">,</span>
            <span class="n">amounts</span><span class="o">=</span><span class="n">amounts</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.burned_register">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.burned_register">[docs]</a>
    <span class="k">def</span> <span class="nf">burned_register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a neuron on the Bittensor network by recycling TAO. This method of registration involves recycling</span>
<span class="sd">            TAO tokens, allowing them to be re-mined by performing work on the network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron to be registered.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block. Defaults to</span>
<span class="sd">                `False`.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">                Defaults to `True`.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the registration is successful, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">netuid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root_register_extrinsic</span><span class="p">(</span>
                <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">burned_register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.commit_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.commit_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">commit_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">salt</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">version_as_int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Commits a hash of the neuron&#39;s weights to the Bittensor blockchain using the provided wallet.</span>
<span class="sd">        This action serves as a commitment or snapshot of the neuron&#39;s current weight distribution.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron committing the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            salt (list[int]): list of randomly generated integers as salt to generated weighted hash.</span>
<span class="sd">            uids (np.ndarray): NumPy array of neuron UIDs for which weights are being committed.</span>
<span class="sd">            weights (np.ndarray): NumPy array of weight values corresponding to each UID.</span>
<span class="sd">            version_key (int): Version key for compatibility with the network. Default is ``int representation of</span>
<span class="sd">                a Bittensor version.``.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is</span>
<span class="sd">                ``False``.</span>
<span class="sd">            max_retries (int): The number of maximum attempts to commit weights. Default is ``5``.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]:</span>
<span class="sd">                `True` if the weight commitment is successful, False otherwise.</span>
<span class="sd">                `msg` is a string value describing the success or potential error.</span>

<span class="sd">        This function allows neurons to create a tamper-proof record of their weight distribution at a specific point</span>
<span class="sd">            in time, enhancing transparency and accountability within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to commit weights!&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Committing weights with params: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;netuid=[blue]</span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2">[/blue], uids=[blue]</span><span class="si">{</span><span class="n">uids</span><span class="si">}</span><span class="s2">[/blue], weights=[blue]</span><span class="si">{</span><span class="n">weights</span><span class="si">}</span><span class="s2">[/blue], &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;version_key=[blue]</span><span class="si">{</span><span class="n">version_key</span><span class="si">}</span><span class="s2">[/blue]&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Generate the hash of the weights</span>
        <span class="n">commit_hash</span> <span class="o">=</span> <span class="n">generate_weight_hash</span><span class="p">(</span>
            <span class="n">address</span><span class="o">=</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">uids</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">uids</span><span class="p">),</span>
            <span class="n">values</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span>
            <span class="n">salt</span><span class="o">=</span><span class="n">salt</span><span class="p">,</span>
            <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">while</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span> <span class="ow">and</span> <span class="n">success</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">commit_weights_extrinsic</span><span class="p">(</span>
                    <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                    <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                    <span class="n">commit_hash</span><span class="o">=</span><span class="n">commit_hash</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                    <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error committing weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>


<div class="viewcode-block" id="Subtensor.modify_liquidity">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.modify_liquidity">[docs]</a>
    <span class="k">def</span> <span class="nf">modify_liquidity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">position_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">liquidity_delta</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">hotkey</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Modifies liquidity in liquidity position by adding or removing liquidity from it.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet: The wallet used to sign the extrinsic (must be unlocked).</span>
<span class="sd">            netuid: The UID of the target subnet for which the call is being initiated.</span>
<span class="sd">            position_id: The id of the position record in the pool.</span>
<span class="sd">            liquidity_delta: The amount of liquidity to be added or removed (add if positive or remove if negative).</span>
<span class="sd">            hotkey: The hotkey with staked TAO in Alpha. If not passed then the wallet hotkey is used. Defaults to</span>
<span class="sd">                `None`.</span>
<span class="sd">            wait_for_inclusion: Whether to wait for the extrinsic to be included in a block. Defaults to True.</span>
<span class="sd">            wait_for_finalization: Whether to wait for finalization of the extrinsic. Defaults to False.</span>
<span class="sd">            period: The number of blocks during which the transaction will remain valid after it&#39;s submitted. If</span>
<span class="sd">                the transaction is not included in a block within that number of blocks, it will expire and be rejected.</span>
<span class="sd">                You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, str]:</span>
<span class="sd">                - True and a success message if the extrinsic is successfully submitted or processed.</span>
<span class="sd">                - False and an error message if the submission fails or the wallet cannot be unlocked.</span>

<span class="sd">        Example:</span>
<span class="sd">            import bittensor as bt</span>

<span class="sd">            subtensor = bt.subtensor(network=&quot;local&quot;)</span>
<span class="sd">            my_wallet = bt.Wallet()</span>

<span class="sd">            # if `liquidity_delta` is negative</span>
<span class="sd">            my_liquidity_delta = Balance.from_tao(100) * -1</span>

<span class="sd">            subtensor.modify_liquidity(</span>
<span class="sd">                wallet=my_wallet,</span>
<span class="sd">                netuid=123,</span>
<span class="sd">                position_id=2,</span>
<span class="sd">                liquidity_delta=my_liquidity_delta</span>
<span class="sd">            )</span>

<span class="sd">            # if `liquidity_delta` is positive</span>
<span class="sd">            my_liquidity_delta = Balance.from_tao(120)</span>

<span class="sd">            subtensor.modify_liquidity(</span>
<span class="sd">                wallet=my_wallet,</span>
<span class="sd">                netuid=123,</span>
<span class="sd">                position_id=2,</span>
<span class="sd">                liquidity_delta=my_liquidity_delta</span>
<span class="sd">            )</span>

<span class="sd">        Note: Modifying is allowed even when user liquidity is enabled in specified subnet. Call `toggle_user_liquidity`</span>
<span class="sd">            to enable/disable user liquidity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">modify_liquidity_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">position_id</span><span class="o">=</span><span class="n">position_id</span><span class="p">,</span>
            <span class="n">liquidity_delta</span><span class="o">=</span><span class="n">liquidity_delta</span><span class="p">,</span>
            <span class="n">hotkey</span><span class="o">=</span><span class="n">hotkey</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.move_stake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.move_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">move_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">origin_hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">origin_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">destination_hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">destination_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves stake to a different hotkey and/or subnet.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet to move stake from.</span>
<span class="sd">            origin_hotkey (str): The SS58 address of the source hotkey.</span>
<span class="sd">            origin_netuid (int): The netuid of the source subnet.</span>
<span class="sd">            destination_hotkey (str): The SS58 address of the destination hotkey.</span>
<span class="sd">            destination_netuid (int): The netuid of the destination subnet.</span>
<span class="sd">            amount (Balance): Amount of stake to move.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            success (bool): True if the stake movement was successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">move_stake_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">origin_hotkey</span><span class="o">=</span><span class="n">origin_hotkey</span><span class="p">,</span>
            <span class="n">origin_netuid</span><span class="o">=</span><span class="n">origin_netuid</span><span class="p">,</span>
            <span class="n">destination_hotkey</span><span class="o">=</span><span class="n">destination_hotkey</span><span class="p">,</span>
            <span class="n">destination_netuid</span><span class="o">=</span><span class="n">destination_netuid</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.register">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.register">[docs]</a>
    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">max_allowed_attempts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">output_in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cuda</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dev_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">tpb</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
        <span class="n">num_processes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">update_interval</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">log_verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a neuron on the Bittensor network using the provided wallet.</span>

<span class="sd">        Registration is a critical step for a neuron to become an active participant in the network, enabling it to</span>
<span class="sd">            stake, set weights, and receive incentives.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron to be registered.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Defaults to `False`.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Defaults to</span>
<span class="sd">                `True`.</span>
<span class="sd">            max_allowed_attempts (int): Maximum number of attempts to register the wallet.</span>
<span class="sd">            output_in_place (bool): If true, prints the progress of the proof of work to the console in-place. Meaning</span>
<span class="sd">                the progress is printed on the same lines. Defaults to `True`.</span>
<span class="sd">            cuda (bool): If ``true``, the wallet should be registered using CUDA device(s). Defaults to `False`.</span>
<span class="sd">            dev_id (Union[List[int], int]): The CUDA device id to use, or a list of device ids. Defaults to `0` (zero).</span>
<span class="sd">            tpb (int): The number of threads per block (CUDA). Default to `256`.</span>
<span class="sd">            num_processes (Optional[int]): The number of processes to use to register. Default to `None`.</span>
<span class="sd">            update_interval (Optional[int]): The number of nonces to solve between updates.  Default to `None`.</span>
<span class="sd">            log_verbose (bool): If ``true``, the registration process will log more information.  Default to `False`.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the registration is successful, False otherwise.</span>

<span class="sd">        This function facilitates the entry of new neurons into the network, supporting the decentralized</span>
<span class="sd">        growth and scalability of the Bittensor ecosystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">max_allowed_attempts</span><span class="o">=</span><span class="n">max_allowed_attempts</span><span class="p">,</span>
            <span class="n">tpb</span><span class="o">=</span><span class="n">tpb</span><span class="p">,</span>
            <span class="n">update_interval</span><span class="o">=</span><span class="n">update_interval</span><span class="p">,</span>
            <span class="n">num_processes</span><span class="o">=</span><span class="n">num_processes</span><span class="p">,</span>
            <span class="n">cuda</span><span class="o">=</span><span class="n">cuda</span><span class="p">,</span>
            <span class="n">dev_id</span><span class="o">=</span><span class="n">dev_id</span><span class="p">,</span>
            <span class="n">output_in_place</span><span class="o">=</span><span class="n">output_in_place</span><span class="p">,</span>
            <span class="n">log_verbose</span><span class="o">=</span><span class="n">log_verbose</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.register_subnet">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.register_subnet">[docs]</a>
    <span class="k">def</span> <span class="nf">register_subnet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a new subnetwork on the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet to be used for subnet registration.</span>
<span class="sd">            wait_for_inclusion (bool): If set, waits for the extrinsic to enter a block before returning `True`, or</span>
<span class="sd">                returns `False` if the extrinsic fails to enter the block within the timeout. Default is `False`.</span>
<span class="sd">            wait_for_finalization (bool): If set, waits for the extrinsic to be finalized on the chain before returning</span>
<span class="sd">                `True`, or returns `False` if the extrinsic fails to be finalized within the timeout. Default is `True`.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the subnet registration was successful, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">register_subnet_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.remove_liquidity">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.remove_liquidity">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_liquidity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">position_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">hotkey</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove liquidity and credit balances back to wallet&#39;s hotkey stake.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet: The wallet used to sign the extrinsic (must be unlocked).</span>
<span class="sd">            netuid: The UID of the target subnet for which the call is being initiated.</span>
<span class="sd">            position_id: The id of the position record in the pool.</span>
<span class="sd">            hotkey: The hotkey with staked TAO in Alpha. If not passed then the wallet hotkey is used. Defaults to</span>
<span class="sd">                `None`.</span>
<span class="sd">            wait_for_inclusion: Whether to wait for the extrinsic to be included in a block. Defaults to True.</span>
<span class="sd">            wait_for_finalization: Whether to wait for finalization of the extrinsic. Defaults to False.</span>
<span class="sd">            period: The number of blocks during which the transaction will remain valid after it&#39;s submitted. If</span>
<span class="sd">                the transaction is not included in a block within that number of blocks, it will expire and be rejected.</span>
<span class="sd">                You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, str]:</span>
<span class="sd">                - True and a success message if the extrinsic is successfully submitted or processed.</span>
<span class="sd">                - False and an error message if the submission fails or the wallet cannot be unlocked.</span>

<span class="sd">        Note:</span>
<span class="sd">            - Adding is allowed even when user liquidity is enabled in specified subnet. Call `toggle_user_liquidity`</span>
<span class="sd">                extrinsic to enable/disable user liquidity.</span>
<span class="sd">            - To get the `position_id` use `get_liquidity_list` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">remove_liquidity_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">position_id</span><span class="o">=</span><span class="n">position_id</span><span class="p">,</span>
            <span class="n">hotkey</span><span class="o">=</span><span class="n">hotkey</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.reveal_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.reveal_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">reveal_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">salt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">version_as_int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reveals the weights for a specific subnet on the Bittensor blockchain using the provided wallet.</span>
<span class="sd">        This action serves as a revelation of the neuron&#39;s previously committed weight distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): The wallet associated with the neuron revealing the weights.</span>
<span class="sd">            netuid (int): The unique identifier of the subnet.</span>
<span class="sd">            uids (np.ndarray): NumPy array of neuron UIDs for which weights are being revealed.</span>
<span class="sd">            weights (np.ndarray): NumPy array of weight values corresponding to each UID.</span>
<span class="sd">            salt (np.ndarray): NumPy array of salt values corresponding to the hash function.</span>
<span class="sd">            version_key (int): Version key for compatibility with the network. Default is ``int representation of</span>
<span class="sd">                the Bittensor version``.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is</span>
<span class="sd">                ``False``.</span>
<span class="sd">            max_retries (int): The number of maximum attempts to reveal weights. Default is ``5``.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: ``True`` if the weight revelation is successful, False otherwise. And `msg`, a string</span>
<span class="sd">                value describing the success or potential error.</span>

<span class="sd">        This function allows neurons to reveal their previously committed weight distribution, ensuring transparency</span>
<span class="sd">            and accountability within the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to reveal weights!&quot;</span>

        <span class="k">while</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span> <span class="ow">and</span> <span class="n">success</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">reveal_weights_extrinsic</span><span class="p">(</span>
                    <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                    <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                    <span class="n">uids</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">uids</span><span class="p">),</span>
                    <span class="n">weights</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span>
                    <span class="n">salt</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">salt</span><span class="p">),</span>
                    <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                    <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error revealing weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>


<div class="viewcode-block" id="Subtensor.root_register">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.root_register">[docs]</a>
    <span class="k">def</span> <span class="nf">root_register</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register neuron by recycling some TAO.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): Bittensor wallet instance.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is</span>
<span class="sd">                ``False``.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if registration was successful, otherwise `False`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">root_register_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.root_set_pending_childkey_cooldown">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.root_set_pending_childkey_cooldown">[docs]</a>
    <span class="k">def</span> <span class="nf">root_set_pending_childkey_cooldown</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">cooldown</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the pending childkey cooldown.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet: bittensor wallet instance.</span>
<span class="sd">            cooldown: the number of blocks to setting pending childkey cooldown.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is</span>
<span class="sd">                ``False``.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: A tuple where the first element is a boolean indicating success or failure of the</span>
<span class="sd">                operation, and the second element is a message providing additional information.</span>

<span class="sd">        Note: This operation can only be successfully performed if your wallet has root privileges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">root_set_pending_childkey_cooldown_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">cooldown</span><span class="o">=</span><span class="n">cooldown</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">root_set_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set weights for the root network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): bittensor wallet instance.</span>
<span class="sd">            netuids (list[int]): The list of subnet uids.</span>
<span class="sd">            weights (list[float]): The list of weights to be set.</span>
<span class="sd">            version_key (int, optional): Version key for compatibility with the network. Default is ``0``.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Waits for the transaction to be included in a block. Defaults to</span>
<span class="sd">                ``False``.</span>
<span class="sd">            wait_for_finalization (bool, optional): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">                Defaults to ``False``.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the setting of weights is successful, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">netuids_</span><span class="p">,</span> <span class="n">weights_</span> <span class="o">=</span> <span class="n">convert_uids_and_weights</span><span class="p">(</span><span class="n">netuids</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Setting weights in network: [blue]</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="si">}</span><span class="s2">[/blue]&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">set_root_weights_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuids</span><span class="o">=</span><span class="n">netuids_</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights_</span><span class="p">,</span>
            <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Subtensor.set_children">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.set_children">[docs]</a>
    <span class="k">def</span> <span class="nf">set_children</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">children</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">raise_error</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allows a coldkey to set children-keys.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet: bittensor wallet instance.</span>
<span class="sd">            hotkey: The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            netuid: The netuid value.</span>
<span class="sd">            children: A list of children with their proportions.</span>
<span class="sd">            wait_for_inclusion: Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization: Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            raise_error: Raises a relevant exception rather than returning `False` if unsuccessful.</span>
<span class="sd">            period: The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: A tuple where the first element is a boolean indicating success or failure of the</span>
<span class="sd">                operation, and the second element is a message providing additional information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">set_children_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey</span><span class="o">=</span><span class="n">hotkey</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">children</span><span class="o">=</span><span class="n">children</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="n">raise_error</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.set_delegate_take">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.set_delegate_take">[docs]</a>
    <span class="k">def</span> <span class="nf">set_delegate_take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">take</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">raise_error</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the delegate &#39;take&#39; percentage for a neuron identified by its hotkey.</span>
<span class="sd">        The &#39;take&#39; represents the percentage of rewards that the delegate claims from its nominators&#39; stakes.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): bittensor wallet instance.</span>
<span class="sd">            hotkey_ss58 (str): The ``SS58`` address of the neuron&#39;s hotkey.</span>
<span class="sd">            take (float): Percentage reward for the delegate.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            raise_error: Raises a relevant exception rather than returning `False` if unsuccessful.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: A tuple where the first element is a boolean indicating success or failure of the</span>
<span class="sd">             operation, and the second element is a message providing additional information.</span>

<span class="sd">        Raises:</span>
<span class="sd">            DelegateTakeTooHigh: Delegate take is too high.</span>
<span class="sd">            DelegateTakeTooLow: Delegate take is too low.</span>
<span class="sd">            DelegateTxRateLimitExceeded: A transactor exceeded the rate limit for delegate transaction.</span>
<span class="sd">            HotKeyAccountNotExists: The hotkey does not exist.</span>
<span class="sd">            NonAssociatedColdKey: Request to stake, unstake, or subscribe is made by a coldkey that is not associated</span>
<span class="sd">                with the hotkey account.</span>
<span class="sd">            bittensor_wallet.errors.PasswordError: Decryption failed or wrong password for decryption provided.</span>
<span class="sd">            bittensor_wallet.errors.KeyFileError: Failed to decode keyfile data.</span>

<span class="sd">        The delegate take is a critical parameter in the network&#39;s incentive structure, influencing the distribution of</span>
<span class="sd">            rewards among neurons and their nominators.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># u16 representation of the take</span>
        <span class="n">take_u16</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">take</span> <span class="o">*</span> <span class="mh">0xFFFF</span><span class="p">)</span>

        <span class="n">current_take</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_delegate_take</span><span class="p">(</span><span class="n">hotkey_ss58</span><span class="p">)</span>
        <span class="n">current_take_u16</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">current_take</span> <span class="o">*</span> <span class="mh">0xFFFF</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">current_take_u16</span> <span class="o">==</span> <span class="n">take_u16</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;:white_heavy_check_mark: [green]Already Set[/green]&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Updating </span><span class="si">{</span><span class="n">hotkey_ss58</span><span class="si">}</span><span class="s2"> take: current=</span><span class="si">{</span><span class="n">current_take</span><span class="si">}</span><span class="s2"> new=</span><span class="si">{</span><span class="n">take</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">current_take_u16</span> <span class="o">&lt;</span> <span class="n">take_u16</span><span class="p">:</span>
            <span class="n">success</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="n">increase_take_extrinsic</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">wallet</span><span class="p">,</span>
                <span class="n">hotkey_ss58</span><span class="p">,</span>
                <span class="n">take_u16</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">raise_error</span><span class="o">=</span><span class="n">raise_error</span><span class="p">,</span>
                <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">success</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="n">decrease_take_extrinsic</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">wallet</span><span class="p">,</span>
                <span class="n">hotkey_ss58</span><span class="p">,</span>
                <span class="n">take_u16</span><span class="p">,</span>
                <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                <span class="n">raise_error</span><span class="o">=</span><span class="n">raise_error</span><span class="p">,</span>
                <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;:white_heavy_check_mark: [green]Take Updated[/green]&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">error</span></div>


<div class="viewcode-block" id="Subtensor.set_subnet_identity">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.set_subnet_identity">[docs]</a>
    <span class="k">def</span> <span class="nf">set_subnet_identity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">subnet_identity</span><span class="p">:</span> <span class="n">SubnetIdentity</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the identity of a subnet for a specific wallet and network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (Wallet): The wallet instance that will authorize the transaction.</span>
<span class="sd">            netuid (int): The unique ID of the network on which the operation takes place.</span>
<span class="sd">            subnet_identity (SubnetIdentity): The identity data of the subnet including attributes like name, GitHub</span>
<span class="sd">                repository, contact, URL, discord, description, and any additional metadata.</span>
<span class="sd">            wait_for_inclusion (bool): Indicates if the function should wait for the transaction to be included in the</span>
<span class="sd">                block.</span>
<span class="sd">            wait_for_finalization (bool): Indicates if the function should wait for the transaction to reach</span>
<span class="sd">                finalization.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]: A tuple where the first element is a boolean indicating success or failure of the</span>
<span class="sd">             operation, and the second element is a message providing additional information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">set_subnet_identity_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">subnet_name</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">subnet_name</span><span class="p">,</span>
            <span class="n">github_repo</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">github_repo</span><span class="p">,</span>
            <span class="n">subnet_contact</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">subnet_contact</span><span class="p">,</span>
            <span class="n">subnet_url</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">subnet_url</span><span class="p">,</span>
            <span class="n">logo_url</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">logo_url</span><span class="p">,</span>
            <span class="n">discord</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">discord</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
            <span class="n">additional</span><span class="o">=</span><span class="n">subnet_identity</span><span class="o">.</span><span class="n">additional</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.set_weights">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.set_weights">[docs]</a>
    <span class="k">def</span> <span class="nf">set_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">uids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="s2">&quot;torch.LongTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span> <span class="s2">&quot;torch.FloatTensor&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">version_key</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">version_as_int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_retries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">block_time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">12.0</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the interneuronal weights for the specified neuron. This process involves specifying the influence or</span>
<span class="sd">            trust a neuron places on other neurons in the network, which is a fundamental aspect of Bittensor&#39;s</span>
<span class="sd">            decentralized learning architecture.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet: The wallet associated with the neuron setting the weights.</span>
<span class="sd">            netuid: The unique identifier of the subnet.</span>
<span class="sd">            uids: The list of neuron UIDs that the weights are being set for.</span>
<span class="sd">            weights: The corresponding weights to be set for each UID.</span>
<span class="sd">            version_key: Version key for compatibility with the network.  Default is int representation of a Bittensor</span>
<span class="sd">                version.</span>
<span class="sd">            wait_for_inclusion: Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization: Waits for the transaction to be finalized on the blockchain. Default is ``False``.</span>
<span class="sd">            max_retries: The number of maximum attempts to set weights. Default is ``5``.</span>
<span class="sd">            block_time: The number of seconds for block duration. Default is 12.0 seconds.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction. Default is 8.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple:</span>
<span class="sd">                `True` if the setting of weights is successful, `False` otherwise.</span>
<span class="sd">                `msg` is a string value describing the success or potential error.</span>

<span class="sd">        This function is crucial in shaping the network&#39;s collective intelligence, where each neuron&#39;s learning and</span>
<span class="sd">            contribution are influenced by the weights it sets towards others.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_blocks_weight_limit</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">bslu</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_since_last_update</span><span class="p">(</span><span class="n">netuid</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">uid</span><span class="p">)))</span>
            <span class="n">wrl</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_rate_limit</span><span class="p">(</span><span class="n">netuid</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">bslu</span> <span class="o">&gt;</span> <span class="n">wrl</span>

        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No attempt made. Perhaps it is too soon to commit weights!&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">uid</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_uid_for_hotkey_on_subnet</span><span class="p">(</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="p">,</span> <span class="n">netuid</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="kc">False</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Hotkey </span><span class="si">{</span><span class="n">wallet</span><span class="o">.</span><span class="n">hotkey</span><span class="o">.</span><span class="n">ss58_address</span><span class="si">}</span><span class="s2"> not registered in subnet </span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">commit_reveal_enabled</span><span class="p">(</span><span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">):</span>
            <span class="c1"># go with `commit reveal v3` extrinsic</span>

            <span class="k">while</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span> <span class="ow">and</span> <span class="n">success</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">_blocks_weight_limit</span><span class="p">():</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Committing weights for subnet [blue]</span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2">[/blue]. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Attempt [blue]</span><span class="si">{</span><span class="n">retries</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">[blue] of [green]</span><span class="si">{</span><span class="n">max_retries</span><span class="si">}</span><span class="s2">[/green].&quot;</span>
                <span class="p">)</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">commit_reveal_v3_extrinsic</span><span class="p">(</span>
                    <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                    <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                    <span class="n">uids</span><span class="o">=</span><span class="n">uids</span><span class="p">,</span>
                    <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                    <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
                    <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                    <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                    <span class="n">block_time</span><span class="o">=</span><span class="n">block_time</span><span class="p">,</span>
                    <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># go with classic `set_weights_extrinsic`</span>

            <span class="k">while</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="n">max_retries</span> <span class="ow">and</span> <span class="n">success</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">_blocks_weight_limit</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Setting weights for subnet [blue]</span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2">[/blue]. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Attempt [blue]</span><span class="si">{</span><span class="n">retries</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">[/blue] of [green]</span><span class="si">{</span><span class="n">max_retries</span><span class="si">}</span><span class="s2">[/green].&quot;</span>
                    <span class="p">)</span>
                    <span class="n">success</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">set_weights_extrinsic</span><span class="p">(</span>
                        <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
                        <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
                        <span class="n">uids</span><span class="o">=</span><span class="n">uids</span><span class="p">,</span>
                        <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                        <span class="n">version_key</span><span class="o">=</span><span class="n">version_key</span><span class="p">,</span>
                        <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
                        <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
                        <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error setting weights: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">retries</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">message</span></div>


<div class="viewcode-block" id="Subtensor.serve_axon">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.serve_axon">[docs]</a>
    <span class="k">def</span> <span class="nf">serve_axon</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">axon</span><span class="p">:</span> <span class="s2">&quot;Axon&quot;</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">certificate</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Certificate</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers an ``Axon`` serving endpoint on the Bittensor network for a specific neuron. This function is used to</span>
<span class="sd">            set up the Axon, a key component of a neuron that handles incoming queries and data processing tasks.</span>

<span class="sd">        Args:</span>
<span class="sd">            netuid (int): The unique identifier of the subnetwork.</span>
<span class="sd">            axon (bittensor.core.axon.Axon): The Axon instance to be registered for serving.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block. Default is ``False``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain. Default is</span>
<span class="sd">                ``True``.</span>
<span class="sd">            certificate (bittensor.utils.Certificate): Certificate to use for TLS. If ``None``, no TLS will be used.</span>
<span class="sd">                Defaults to ``None``.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the Axon serve registration is successful, False otherwise.</span>

<span class="sd">        By registering an Axon, the neuron becomes an active part of the network&#39;s distributed computing infrastructure,</span>
<span class="sd">            contributing to the collective intelligence of Bittensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">serve_axon_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">axon</span><span class="o">=</span><span class="n">axon</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">certificate</span><span class="o">=</span><span class="n">certificate</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.start_call">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.start_call">[docs]</a>
    <span class="k">def</span> <span class="nf">start_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Submits a start_call extrinsic to the blockchain, to trigger the start call process for a subnet (used to start</span>
<span class="sd">            a new subnet&#39;s emission mechanism).</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (Wallet): The wallet used to sign the extrinsic (must be unlocked).</span>
<span class="sd">            netuid (int): The UID of the target subnet for which the call is being initiated.</span>
<span class="sd">            wait_for_inclusion (bool, optional): Whether to wait for the extrinsic to be included in a block.</span>
<span class="sd">                Defaults to `True`.</span>
<span class="sd">            wait_for_finalization (bool, optional): Whether to wait for finalization of the extrinsic.</span>
<span class="sd">                Defaults to `False`.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, str]:</span>
<span class="sd">                - True and a success message if the extrinsic is successfully submitted or processed.</span>
<span class="sd">                - False and an error message if the submission fails or the wallet cannot be unlocked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">start_call_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.swap_stake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.swap_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">swap_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">origin_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">destination_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">safe_staking</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_partial_stake</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">rate_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves stake between subnets while keeping the same coldkey-hotkey pair ownership.</span>
<span class="sd">        Like subnet hopping - same owner, same hotkey, just changing which subnet the stake is in.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet to swap stake from.</span>
<span class="sd">            hotkey_ss58 (str): The SS58 address of the hotkey whose stake is being swapped.</span>
<span class="sd">            origin_netuid (int): The netuid from which stake is removed.</span>
<span class="sd">            destination_netuid (int): The netuid to which stake is added.</span>
<span class="sd">            amount (Union[Balance, float]): The amount to swap.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            safe_staking (bool): If true, enables price safety checks to protect against fluctuating prices. The swap</span>
<span class="sd">                will only execute if the price ratio between subnets doesn&#39;t exceed the rate tolerance.</span>
<span class="sd">                Default is False.</span>
<span class="sd">            allow_partial_stake (bool): If true and safe_staking is enabled, allows partial stake swaps when</span>
<span class="sd">                the full amount would exceed the price tolerance. If false, the entire swap fails if it would</span>
<span class="sd">                exceed the tolerance. Default is False.</span>
<span class="sd">            rate_tolerance (float): The maximum allowed increase in the price ratio between subnets</span>
<span class="sd">                (origin_price/destination_price). For example, 0.005 = 0.5% maximum increase. Only used</span>
<span class="sd">                when safe_staking is True. Default is 0.005.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            success (bool): True if the extrinsic was successful.</span>

<span class="sd">        The price ratio for swap_stake in safe mode is calculated as: origin_subnet_price / destination_subnet_price</span>
<span class="sd">        When safe_staking is enabled, the swap will only execute if:</span>
<span class="sd">            - With allow_partial_stake=False: The entire swap amount can be executed without the price ratio</span>
<span class="sd">            increasing more than rate_tolerance</span>
<span class="sd">            - With allow_partial_stake=True: A partial amount will be swapped up to the point where the</span>
<span class="sd">            price ratio would increase by rate_tolerance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">swap_stake_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58</span><span class="o">=</span><span class="n">hotkey_ss58</span><span class="p">,</span>
            <span class="n">origin_netuid</span><span class="o">=</span><span class="n">origin_netuid</span><span class="p">,</span>
            <span class="n">destination_netuid</span><span class="o">=</span><span class="n">destination_netuid</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">safe_staking</span><span class="o">=</span><span class="n">safe_staking</span><span class="p">,</span>
            <span class="n">allow_partial_stake</span><span class="o">=</span><span class="n">allow_partial_stake</span><span class="p">,</span>
            <span class="n">rate_tolerance</span><span class="o">=</span><span class="n">rate_tolerance</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.toggle_user_liquidity">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.toggle_user_liquidity">[docs]</a>
    <span class="k">def</span> <span class="nf">toggle_user_liquidity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">enable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Allow to toggle user liquidity for specified subnet.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet: The wallet used to sign the extrinsic (must be unlocked).</span>
<span class="sd">            netuid: The UID of the target subnet for which the call is being initiated.</span>
<span class="sd">            enable: Boolean indicating whether to enable user liquidity.</span>
<span class="sd">            wait_for_inclusion: Whether to wait for the extrinsic to be included in a block. Defaults to True.</span>
<span class="sd">            wait_for_finalization: Whether to wait for finalization of the extrinsic. Defaults to False.</span>
<span class="sd">            period: The number of blocks during which the transaction will remain valid after it&#39;s submitted. If</span>
<span class="sd">                the transaction is not included in a block within that number of blocks, it will expire and be rejected.</span>
<span class="sd">                You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[bool, str]:</span>
<span class="sd">                - True and a success message if the extrinsic is successfully submitted or processed.</span>
<span class="sd">                - False and an error message if the submission fails or the wallet cannot be unlocked.</span>

<span class="sd">        Note: The call can be executed successfully by the subnet owner only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">toggle_user_liquidity_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">enable</span><span class="o">=</span><span class="n">enable</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.transfer">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.transfer">[docs]</a>
    <span class="k">def</span> <span class="nf">transfer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">transfer_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_alive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transfer token of amount to destination.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet (bittensor_wallet.Wallet): Source wallet for the transfer.</span>
<span class="sd">            dest (str): Destination address for the transfer.</span>
<span class="sd">            amount (float): Amount of tao to transfer.</span>
<span class="sd">            transfer_all (bool): Flag to transfer all tokens. Default is ``False``.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.  Default is ``True``.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.  Default is</span>
<span class="sd">                ``False``.</span>
<span class="sd">            keep_alive (bool): Flag to keep the connection alive. Default is ``True``.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if the transferring was successful, otherwise `False`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transfer_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">transfer_all</span><span class="o">=</span><span class="n">transfer_all</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">keep_alive</span><span class="o">=</span><span class="n">keep_alive</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.transfer_stake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.transfer_stake">[docs]</a>
    <span class="k">def</span> <span class="nf">transfer_stake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">destination_coldkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">origin_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">destination_netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Balance</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transfers stake from one subnet to another while changing the coldkey owner.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet (bittensor.wallet): The wallet to transfer stake from.</span>
<span class="sd">            destination_coldkey_ss58 (str): The destination coldkey SS58 address.</span>
<span class="sd">            hotkey_ss58 (str): The hotkey SS58 address associated with the stake.</span>
<span class="sd">            origin_netuid (int): The source subnet UID.</span>
<span class="sd">            destination_netuid (int): The destination subnet UID.</span>
<span class="sd">            amount (Union[Balance, float, int]): Amount to transfer.</span>
<span class="sd">            wait_for_inclusion (bool): If true, waits for inclusion before returning.</span>
<span class="sd">            wait_for_finalization (bool): If true, waits for finalization before returning.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            success (bool): True if the transfer was successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transfer_stake_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">destination_coldkey_ss58</span><span class="o">=</span><span class="n">destination_coldkey_ss58</span><span class="p">,</span>
            <span class="n">hotkey_ss58</span><span class="o">=</span><span class="n">hotkey_ss58</span><span class="p">,</span>
            <span class="n">origin_netuid</span><span class="o">=</span><span class="n">origin_netuid</span><span class="p">,</span>
            <span class="n">destination_netuid</span><span class="o">=</span><span class="n">destination_netuid</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.unstake">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.unstake">[docs]</a>
    <span class="k">def</span> <span class="nf">unstake</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Balance</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">safe_staking</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_partial_stake</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">rate_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unstake_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a specified amount of stake from a single hotkey account. This function is critical for adjusting</span>
<span class="sd">            individual neuron stakes within the Bittensor network.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet: The wallet associated with the neuron from which the stake is being removed.</span>
<span class="sd">            hotkey_ss58: The ``SS58`` address of the hotkey account to unstake from.</span>
<span class="sd">            netuid: The unique identifier of the subnet.</span>
<span class="sd">            amount: The amount of alpha to unstake. If not specified, unstakes all. Alpha amount.</span>
<span class="sd">            wait_for_inclusion: Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization: Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            safe_staking: If true, enables price safety checks to protect against fluctuating prices. The unstake</span>
<span class="sd">                will only execute if the price change doesn&#39;t exceed the rate tolerance. Default is False.</span>
<span class="sd">            allow_partial_stake (bool): If true and safe_staking is enabled, allows partial unstaking when</span>
<span class="sd">                the full amount would exceed the price tolerance. If false, the entire unstake fails if it would</span>
<span class="sd">                exceed the tolerance. Default is False.</span>
<span class="sd">            rate_tolerance (float): The maximum allowed price change ratio when unstaking. For example,</span>
<span class="sd">                0.005 = 0.5% maximum price decrease. Only used when safe_staking is True. Default is 0.005.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>
<span class="sd">            unstake_all: If `True`, unstakes all tokens, and `amount` is ignored. Default is `False`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the unstaking process is successful, False otherwise.</span>

<span class="sd">        This function supports flexible stake management, allowing neurons to adjust their network participation and</span>
<span class="sd">            potential reward accruals. When safe_staking is enabled, it provides protection against price fluctuations</span>
<span class="sd">            during the time unstake is executed and the time it is actually processed by the chain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">check_and_convert_to_balance</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unstake_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58</span><span class="o">=</span><span class="n">hotkey_ss58</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">amount</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">safe_staking</span><span class="o">=</span><span class="n">safe_staking</span><span class="p">,</span>
            <span class="n">allow_partial_stake</span><span class="o">=</span><span class="n">allow_partial_stake</span><span class="p">,</span>
            <span class="n">rate_tolerance</span><span class="o">=</span><span class="n">rate_tolerance</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
            <span class="n">unstake_all</span><span class="o">=</span><span class="n">unstake_all</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.unstake_all">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.unstake_all">[docs]</a>
    <span class="k">def</span> <span class="nf">unstake_all</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">netuid</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">rate_tolerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unstakes all TAO/Alpha associated with a hotkey from the specified subnets on the Bittensor network.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            wallet: The wallet of the stake owner.</span>
<span class="sd">            hotkey: The SS58 address of the hotkey to unstake from.</span>
<span class="sd">            netuid: The unique identifier of the subnet.</span>
<span class="sd">            rate_tolerance: The maximum allowed price change ratio when unstaking. For example, 0.005 = 0.5% maximum</span>
<span class="sd">                price decrease. If not passed (None), then unstaking goes without price limit. Default is 0.005.</span>
<span class="sd">            wait_for_inclusion: Waits for the transaction to be included in a block. Default is `True`.</span>
<span class="sd">            wait_for_finalization: Waits for the transaction to be finalized on the blockchain. Default is `False`.</span>
<span class="sd">            period: The number of blocks during which the transaction will remain valid after it&#39;s submitted. If the</span>
<span class="sd">                transaction is not included in a block within that number of blocks, it will expire and be rejected. You</span>
<span class="sd">                can think of it as an expiration date for the transaction. Default is `None`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[bool, str]:</span>
<span class="sd">                A tuple containing:</span>
<span class="sd">                - `True` and a success message if the unstake operation succeeded;</span>
<span class="sd">                - `False` and an error message otherwise.</span>

<span class="sd">        Example:</span>
<span class="sd">            # If you would like to unstake all stakes in all subnets safely:</span>
<span class="sd">            import bittensor as bt</span>

<span class="sd">            subtensor = bt.Subtensor()</span>
<span class="sd">            wallet = bt.Wallet(&quot;my_wallet&quot;)</span>
<span class="sd">            netuid = 14</span>
<span class="sd">            hotkey = &quot;5%SOME_HOTKEY%&quot;</span>

<span class="sd">            wallet_stakes = subtensor.get_stake_info_for_coldkey(coldkey_ss58=wallet.coldkey.ss58_address)</span>

<span class="sd">            for stake in wallet_stakes:</span>
<span class="sd">                result = subtensor.unstake_all(</span>
<span class="sd">                    wallet=wallet,</span>
<span class="sd">                    hotkey_ss58=stake.hotkey_ss58,</span>
<span class="sd">                    netuid=stake.netuid,</span>
<span class="sd">                )</span>
<span class="sd">                print(result)</span>

<span class="sd">            # If you would like to unstake all stakes in all subnets unsafely, use `rate_tolerance=None`:</span>
<span class="sd">                        import bittensor as bt</span>

<span class="sd">            subtensor = bt.AsyncSubtensor()</span>
<span class="sd">            wallet = bt.Wallet(&quot;my_wallet&quot;)</span>
<span class="sd">            netuid = 14</span>
<span class="sd">            hotkey = &quot;5%SOME_HOTKEY_WHERE_IS_YOUR_STAKE_NOW%&quot;</span>

<span class="sd">            wallet_stakes = await subtensor.get_stake_info_for_coldkey(coldkey_ss58=wallet.coldkey.ss58_address)</span>

<span class="sd">            for stake in wallet_stakes:</span>
<span class="sd">                result = await subtensor.unstake_all(</span>
<span class="sd">                    wallet=wallet,</span>
<span class="sd">                    hotkey_ss58=stake.hotkey_ss58,</span>
<span class="sd">                    netuid=stake.netuid,</span>
<span class="sd">                    rate_tolerance=None,</span>
<span class="sd">                )</span>
<span class="sd">                print(result)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">netuid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unstaking without Alpha price control from subnet [blue]#</span><span class="si">{</span><span class="n">netuid</span><span class="si">}</span><span class="s2">[/blue].&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">unstake_all_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey</span><span class="o">=</span><span class="n">hotkey</span><span class="p">,</span>
            <span class="n">netuid</span><span class="o">=</span><span class="n">netuid</span><span class="p">,</span>
            <span class="n">rate_tolerance</span><span class="o">=</span><span class="n">rate_tolerance</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Subtensor.unstake_multiple">
<a class="viewcode-back" href="../../../autoapi/bittensor/core/subtensor/index.html#bittensor.core.subtensor.Subtensor.unstake_multiple">[docs]</a>
    <span class="k">def</span> <span class="nf">unstake_multiple</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wallet</span><span class="p">:</span> <span class="s2">&quot;Wallet&quot;</span><span class="p">,</span>
        <span class="n">hotkey_ss58s</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">netuids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">amounts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Balance</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wait_for_inclusion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wait_for_finalization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unstake_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs batch unstaking from multiple hotkey accounts, allowing a neuron to reduce its staked amounts</span>
<span class="sd">            efficiently. This function is useful for managing the distribution of stakes across multiple neurons.</span>

<span class="sd">        Args:</span>
<span class="sd">            wallet: The wallet linked to the coldkey from which the stakes are being</span>
<span class="sd">                withdrawn.</span>
<span class="sd">            hotkey_ss58s (List[str]): A list of hotkey ``SS58`` addresses to unstake from.</span>
<span class="sd">            netuids (List[int]): The list of subnet uids.</span>
<span class="sd">            amounts (List[Balance]): The amounts of TAO to unstake from each hotkey. If not provided,</span>
<span class="sd">                unstakes all available stakes.</span>
<span class="sd">            wait_for_inclusion (bool): Waits for the transaction to be included in a block.</span>
<span class="sd">            wait_for_finalization (bool): Waits for the transaction to be finalized on the blockchain.</span>
<span class="sd">            period (Optional[int]): The number of blocks during which the transaction will remain valid after it&#39;s</span>
<span class="sd">                submitted. If the transaction is not included in a block within that number of blocks, it will expire</span>
<span class="sd">                and be rejected. You can think of it as an expiration date for the transaction.</span>
<span class="sd">            unstake_all: If `True`, unstakes all tokens, and `amounts` is ignored. Default is `False`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: ``True`` if the batch unstaking is successful, False otherwise.</span>

<span class="sd">        This function allows for strategic reallocation or withdrawal of stakes, aligning with the dynamic stake</span>
<span class="sd">            management aspect of the Bittensor network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">unstake_multiple_extrinsic</span><span class="p">(</span>
            <span class="n">subtensor</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">wallet</span><span class="o">=</span><span class="n">wallet</span><span class="p">,</span>
            <span class="n">hotkey_ss58s</span><span class="o">=</span><span class="n">hotkey_ss58s</span><span class="p">,</span>
            <span class="n">netuids</span><span class="o">=</span><span class="n">netuids</span><span class="p">,</span>
            <span class="n">amounts</span><span class="o">=</span><span class="n">amounts</span><span class="p">,</span>
            <span class="n">wait_for_inclusion</span><span class="o">=</span><span class="n">wait_for_inclusion</span><span class="p">,</span>
            <span class="n">wait_for_finalization</span><span class="o">=</span><span class="n">wait_for_finalization</span><span class="p">,</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
            <span class="n">unstake_all</span><span class="o">=</span><span class="n">unstake_all</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Opentensor Foundation
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
       Copyright 2024, Opentensor Foundation.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>